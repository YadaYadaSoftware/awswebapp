---
AWSTemplateFormatVersion: 2010-09-09
Description: TaskManager Global Infrastructure - IAM, Aurora Global Database,
  Secrets Manager
Parameters:
  DatabasePassword:
    Type: String
    NoEcho: true
    MinLength: 8
    Description: Password for the Aurora MySQL database
  EngineVersion:
    Type: String
    Description: Aurora MySQL engine version for the global cluster
  GitHubActionsUserArn:
    Type: String
    Description: ARN of the GitHub Actions IAM user from IAM setup stack
Resources:
  GitHubActionsServiceLinkedRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: TaskManager-GitHubActions-ServiceLinkedRole-Policy
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - iam:GetRole
              - iam:CreateServiceLinkedRole
              - iam:DeleteServiceLinkedRole
            Resource: arn:aws:iam::*:role/aws-service-role/*
          - Effect: Allow
            Action:
              - iam:PassRole
            Resource: arn:aws:iam::*:role/TaskManager-*
      Roles:
        - !Ref SharedLambdaExecutionRole
  ECSCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub taskmanager-ecs-role-setup-${AWS::StackName}
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt SharedLambdaExecutionRole.Arn
      Code:
        ZipFile: >
          import boto3

          import json

          import logging


          logger = logging.getLogger()

          logger.setLevel(logging.INFO)


          iam_client = boto3.client('iam')


          def lambda_handler(event, context):
              try:
                  request_type = event.get('RequestType')

                  logger.info(f"Processing {request_type} for ECS service-linked role")

                  if request_type == 'Create':
                      # Try to create ECS service-linked role if it doesn't exist
                      create_ecs_service_linked_role()

                      # Send success response
                      send_response(event, context, 'SUCCESS', {'Message': 'ECS service-linked role setup complete'})
                  else:
                      # For Update/Delete, just succeed
                      send_response(event, context, 'SUCCESS', {'Message': 'ECS service-linked role unchanged'})

              except Exception as e:
                  logger.error(f"Error processing request: {str(e)}")
                  send_response(event, context, 'SUCCESS', {'Message': f'Handled gracefully: {str(e)}'})

          def create_ecs_service_linked_role():
              try:
                  role_name = 'AWSServiceRoleForECS'
                  service_name = 'ecs.amazonaws.com'

                  # Check if the role already exists
                  try:
                      iam_client.get_role(RoleName=role_name)
                      logger.info(f"ECS service-linked role {role_name} already exists")
                      return
                  except iam_client.exceptions.NoSuchEntityException:
                      logger.info(f"ECS service-linked role {role_name} does not exist, creating...")

                  # Create the service-linked role
                  iam_client.create_service_linked_role(
                      AWSServiceName=service_name,
                      Description='Service-linked role for Amazon ECS'
                  )
                  logger.info(f"Successfully created ECS service-linked role {role_name}")

              except Exception as e:
                  logger.warning(f"Could not create ECS service-linked role: {str(e)}")
                  # Don't fail - the role might already exist or we might not have permissions

          def send_response(event, context, response_status, response_data):
              import urllib.request
              import json

              response_url = event.get('ResponseURL')
              if not response_url:
                  return

              response_body = {
                  'Status': response_status,
                  'Reason': response_data.get('Message', 'Operation completed'),
                  'PhysicalResourceId': event.get('PhysicalResourceId', context.log_stream_name),
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'Content-Type': '',
                  'Content-Length': str(len(json_response_body))
              }

              req = urllib.request.Request(response_url, data=json_response_body.encode('utf-8'), headers=headers, method='PUT')
              try:
                  with urllib.request.urlopen(req) as response:
                      logger.info(f"Response sent: {response.status}")
              except Exception as e:
                  logger.error(f"Failed to send response: {str(e)}")
      Tags:
        - Key: Stack
          Value: !Ref "AWS::StackName"
  ECSRoleSetupResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt ECSCleanupFunction.Arn
    DependsOn:
      - SharedLambdaExecutionRole
      - ECSCleanupFunction
  SharedLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub TaskManager-Shared-Lambda-Role-${AWS::Region}
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:DescribeSecret
                Resource:
                  - !Sub arn:aws:secretsmanager:us-east-1:${AWS::AccountId}:secret:taskmanager/database/regional/us-east-1*
                  - !Sub arn:aws:secretsmanager:us-east-2:${AWS::AccountId}:secret:taskmanager/database/regional/us-east-2*
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub arn:aws:logs:us-east-1:${AWS::AccountId}:*
                  - !Sub arn:aws:logs:us-east-2:${AWS::AccountId}:*
        - PolicyName: RDSAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - rds:CreateDBCluster
                  - rds:ModifyDBCluster
                  - rds:DeleteDBCluster
                  - rds:DescribeDBClusters
                  - rds:DescribeDBInstances
                  - rds:DescribeGlobalClusters
                  - rds:ModifyGlobalCluster
                  - rds:DeleteGlobalCluster
                  - rds-data:ExecuteStatement
                  - rds-data:BatchExecuteStatement
                Resource:
                  - !Sub arn:aws:rds:us-east-1:${AWS::AccountId}:cluster:taskmanager-*
                  - !Sub arn:aws:rds:us-east-2:${AWS::AccountId}:cluster:taskmanager-*
                  - !Sub arn:aws:rds::${AWS::AccountId}:global-cluster:taskmanager-global-cluster
        - PolicyName: KMSAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - kms:CreateKey
                  - kms:DescribeKey
                  - kms:CreateGrant
                  - kms:Decrypt
                  - kms:Encrypt
                  - kms:GenerateDataKey
                  - kms:ReEncryptFrom
                  - kms:ReEncryptTo
                  - kms:RetireGrant
                  - kms:CreateAlias
                  - kms:DeleteAlias
                  - kms:UpdateAlias
                  - kms:ListAliases
                  - kms:ListGrants
                  - kms:RevokeGrant
                  - kms:ReplicateKey
                  - kms:DisableKey
                  - kms:ScheduleKeyDeletion
                Resource: "*"
      Tags:
        - Key: Stack
          Value: !Ref "AWS::StackName"
  BastionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub TaskManager-Bastion-Role-${AWS::Region}
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: SecretsManagerRead
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  - !Sub arn:aws:secretsmanager:us-east-1:${AWS::AccountId}:secret:taskmanager/database/regional/us-east-1*
                  - !Sub arn:aws:secretsmanager:us-east-2:${AWS::AccountId}:secret:taskmanager/database/regional/us-east-2*
      Tags:
        - Key: Stack
          Value: !Ref "AWS::StackName"
  BastionInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref BastionRole
  AuroraKmsKey:
    Type: AWS::KMS::Key
    DeletionPolicy: Retain
    Properties:
      Description: Multi-region KMS key for Aurora Global Database encryption
      KeyUsage: ENCRYPT_DECRYPT
      KeySpec: SYMMETRIC_DEFAULT
      MultiRegion: true
      Enabled: true
      PendingWindowInDays: 7
      KeyPolicy:
        Version: 2012-10-17
        Statement:
          - Sid: EnableIAMUserPermissions
            Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
            Action: kms:*
            Resource: "*"
          - Sid: AllowRDSService
            Effect: Allow
            Principal:
              Service: rds.amazonaws.com
            Action:
              - kms:CreateGrant
              - kms:DescribeKey
              - kms:Decrypt
              - kms:Encrypt
              - kms:GenerateDataKey
              - kms:ReEncryptFrom
              - kms:ReEncryptTo
              - kms:RetireGrant
            Resource: "*"
          - Sid: AllowGitHubActionsUser
            Effect: Allow
            Principal:
              AWS: !Ref GitHubActionsUserArn
            Action:
              - kms:CreateKey
              - kms:DescribeKey
              - kms:CreateGrant
              - kms:Decrypt
              - kms:Encrypt
              - kms:GenerateDataKey
              - kms:ReEncryptFrom
              - kms:ReEncryptTo
              - kms:RetireGrant
              - kms:CreateAlias
              - kms:DeleteAlias
              - kms:UpdateAlias
              - kms:ListAliases
              - kms:ListGrants
              - kms:RevokeGrant
            Resource: "*"
          - Sid: AllowKmsCleanupFunction
            Effect: Allow
            Principal:
              AWS: !GetAtt KmsCleanupFunction.Arn
            Action:
              - kms:DescribeKey
              - kms:DisableKey
              - kms:ScheduleKeyDeletion
            Resource: "*"
      Tags:
        - Key: Stack
          Value: !Ref "AWS::StackName"

  # KMS Key Cleanup Lambda Layer
  KmsCleanupLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub "taskmanager-kms-cleanup-layer-${AWS::StackName}"
      Description: "urllib3 dependency for KMS cleanup Lambda"
      Content:
        S3Bucket: !Sub "taskmanager-templates-bucket-${AWS::Region}"
        S3Key: "kms-cleanup-layer.zip"
      CompatibleRuntimes:
        - python3.9

  # Lambda function to disable KMS key on stack deletion
  KmsCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "taskmanager-kms-cleanup-${AWS::StackName}"
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt SharedLambdaExecutionRole.Arn
      Layers:
        - !Ref KmsCleanupLayer
      Code:
        ZipFile: |
          import boto3
          import json
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          kms_client = boto3.client('kms')

          def lambda_handler(event, context):
              try:
                  request_type = event.get('RequestType')
                  key_id = event.get('ResourceProperties', {}).get('KeyId')

                  if not key_id:
                      raise ValueError("KeyId is required")

                  logger.info(f"Processing {request_type} for KMS key: {key_id}")

                  if request_type == 'Delete':
                      # Disable the KMS key instead of deleting it
                      disable_kms_key(key_id)

                      # Send success response
                      send_response(event, context, 'SUCCESS', {'Message': f'Successfully disabled KMS key {key_id}'})
                  else:
                      # For Create/Update, just succeed
                      send_response(event, context, 'SUCCESS', {'Message': f'KMS key {key_id} ready'})

              except Exception as e:
                  logger.error(f"Error processing request: {str(e)}")
                  send_response(event, context, 'FAILED', {'Error': str(e)})

          def disable_kms_key(key_id):
              try:
                  logger.info(f"Disabling KMS key: {key_id}")

                  # First, describe the key to check its state
                  key_info = kms_client.describe_key(KeyId=key_id)
                  key_state = key_info['KeyMetadata']['KeyState']

                  if key_state == 'Disabled':
                      logger.info(f"KMS key {key_id} is already disabled")
                      return
                  elif key_state == 'PendingDeletion':
                      logger.info(f"KMS key {key_id} is already scheduled for deletion")
                      return

                  # Disable the key
                  kms_client.disable_key(KeyId=key_id)
                  logger.info(f"Successfully disabled KMS key: {key_id}")

                  # Optionally schedule key deletion after 7 days
                  # kms_client.schedule_key_deletion(KeyId=key_id, PendingWindowInDays=7)
                  # logger.info(f"Scheduled KMS key {key_id} for deletion in 7 days")

              except kms_client.exceptions.NotFoundException:
                  logger.warning(f"KMS key {key_id} not found, may have been already deleted")
              except Exception as e:
                  logger.error(f"Error disabling KMS key {key_id}: {str(e)}")
                  raise

          def send_response(event, context, response_status, response_data):
              import urllib3
              import json

              response_url = event.get('ResponseURL')
              if not response_url:
                  return

              response_body = {
                  'Status': response_status,
                  'Reason': response_data.get('Message', 'Operation completed'),
                  'PhysicalResourceId': event.get('PhysicalResourceId', context.log_stream_name),
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              try:
                  response = http.request(
                      'PUT',
                      response_url,
                      body=json_response_body,
                      headers=headers
                  )
                  logger.info(f"Response sent: {response.status}")
              except Exception as e:
                  logger.error(f"Failed to send response: {str(e)}")

  # Custom resource to trigger KMS key disable on stack deletion
  KmsCleanupResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt KmsCleanupFunction.Arn
      KeyId: !Ref AuroraKmsKey
    DependsOn:
      - AuroraKmsKey
      - KmsCleanupFunction

  AuroraGlobalCluster:
    Type: AWS::RDS::GlobalCluster
    Properties:
      GlobalClusterIdentifier: taskmanager-global-cluster
      Engine: aurora-mysql
      EngineVersion: !Ref EngineVersion
      DeletionProtection: false
      StorageEncrypted: true
      Tags:
        - Key: Stack
          Value: !Ref "AWS::StackName"
Outputs:
  SharedLambdaRoleArn:
    Description: Shared Lambda execution role ARN
    Value: !GetAtt SharedLambdaExecutionRole.Arn
    Export:
      Name: TaskManager-SharedLambdaRole
  BastionRoleArn:
    Description: Bastion role ARN
    Value: !GetAtt BastionRole.Arn
    Export:
      Name: TaskManager-BastionRole
  BastionInstanceProfileArn:
    Description: Bastion instance profile ARN
    Value: !Ref BastionInstanceProfile
    Export:
      Name: TaskManager-BastionInstanceProfile
  AuroraGlobalClusterId:
    Description: Aurora Global Database cluster identifier
    Value: !Ref AuroraGlobalCluster
    Export:
      Name: TaskManager-AuroraGlobalCluster
  AuroraKmsKeyArn:
    Description: KMS key ARN used for Aurora encryption
    Value: !GetAtt AuroraKmsKey.Arn
    Export:
      Name: TaskManager-AuroraKmsKey
