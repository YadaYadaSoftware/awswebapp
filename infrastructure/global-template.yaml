AWSTemplateFormatVersion: '2010-09-09'
Description: 'TaskManager Global Infrastructure - IAM, Aurora Global Database, Secrets Manager'

Parameters:
  DatabasePassword:
    Type: String
    NoEcho: true
    MinLength: 8
    Description: 'Password for the Aurora MySQL database'

Resources:

  # IAM Policy for GitHub Actions to manage service-linked roles
  GitHubActionsServiceLinkedRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: 'TaskManager-GitHubActions-ServiceLinkedRole-Policy'
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - iam:GetRole
              - iam:CreateServiceLinkedRole
              - iam:DeleteServiceLinkedRole
            Resource: 'arn:aws:iam::*:role/aws-service-role/*'
          - Effect: Allow
            Action:
              - iam:PassRole
            Resource: 'arn:aws:iam::*:role/TaskManager-*'
      Roles:
        - !Ref SharedLambdaExecutionRole

  # Custom resource to create ECS Service-Linked Role safely
  ECSCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'taskmanager-ecs-role-setup-${AWS::StackName}'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt SharedLambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          iam_client = boto3.client('iam')

          def lambda_handler(event, context):
              try:
                  request_type = event.get('RequestType')

                  logger.info(f"Processing {request_type} for ECS service-linked role")

                  if request_type == 'Create':
                      # Try to create ECS service-linked role if it doesn't exist
                      create_ecs_service_linked_role()

                      # Send success response
                      send_response(event, context, 'SUCCESS', {'Message': 'ECS service-linked role setup complete'})
                  else:
                      # For Update/Delete, just succeed
                      send_response(event, context, 'SUCCESS', {'Message': 'ECS service-linked role unchanged'})

              except Exception as e:
                  logger.error(f"Error processing request: {str(e)}")
                  send_response(event, context, 'SUCCESS', {'Message': f'Handled gracefully: {str(e)}'})

          def create_ecs_service_linked_role():
              try:
                  role_name = 'AWSServiceRoleForECS'
                  service_name = 'ecs.amazonaws.com'

                  # Check if the role already exists
                  try:
                      iam_client.get_role(RoleName=role_name)
                      logger.info(f"ECS service-linked role {role_name} already exists")
                      return
                  except iam_client.exceptions.NoSuchEntityException:
                      logger.info(f"ECS service-linked role {role_name} does not exist, creating...")

                  # Create the service-linked role
                  iam_client.create_service_linked_role(
                      AWSServiceName=service_name,
                      Description='Service-linked role for Amazon ECS'
                  )
                  logger.info(f"Successfully created ECS service-linked role {role_name}")

              except Exception as e:
                  logger.warning(f"Could not create ECS service-linked role: {str(e)}")
                  # Don't fail - the role might already exist or we might not have permissions

          def send_response(event, context, response_status, response_data):
              import urllib.request
              import json

              response_url = event.get('ResponseURL')
              if not response_url:
                  return

              response_body = {
                  'Status': response_status,
                  'Reason': response_data.get('Message', 'Operation completed'),
                  'PhysicalResourceId': event.get('PhysicalResourceId', context.log_stream_name),
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'Content-Type': '',
                  'Content-Length': str(len(json_response_body))
              }

              req = urllib.request.Request(response_url, data=json_response_body.encode('utf-8'), headers=headers, method='PUT')
              try:
                  with urllib.request.urlopen(req) as response:
                      logger.info(f"Response sent: {response.status}")
              except Exception as e:
                  logger.error(f"Failed to send response: {str(e)}")


  # Custom resource to handle ECS service-linked role creation
  ECSRoleSetupResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt ECSCleanupFunction.Arn
    DependsOn: [SharedLambdaExecutionRole, ECSCleanupFunction]

  # Shared Lambda Execution Role
  SharedLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'TaskManager-Shared-Lambda-Role-${AWS::Region}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:DescribeSecret
                Resource:
                  - !Sub 'arn:aws:secretsmanager:us-east-1:${AWS::AccountId}:secret:taskmanager/database/shared/*'
                  - !Sub 'arn:aws:secretsmanager:us-east-2:${AWS::AccountId}:secret:taskmanager/database/shared*'
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:aws:logs:us-east-1:${AWS::AccountId}:*'
                  - !Sub 'arn:aws:logs:us-east-2:${AWS::AccountId}:*'
        - PolicyName: RDSAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - rds:CreateDBCluster
                  - rds:ModifyDBCluster
                  - rds:DeleteDBCluster
                  - rds:DescribeDBClusters
                  - rds:DescribeDBInstances
                  - rds:DescribeGlobalClusters
                  - rds:ModifyGlobalCluster
                  - rds:DeleteGlobalCluster
                  - rds-data:ExecuteStatement
                  - rds-data:BatchExecuteStatement
                Resource:
                  - !Sub 'arn:aws:rds:us-east-1:${AWS::AccountId}:cluster:taskmanager-*'
                  - !Sub 'arn:aws:rds:us-east-2:${AWS::AccountId}:cluster:taskmanager-*'
                  - !Sub 'arn:aws:rds::${AWS::AccountId}:global-cluster:taskmanager-global-cluster'

  # Bastion Role
  BastionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'TaskManager-Bastion-Role-${AWS::Region}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: SecretsManagerRead
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  - !Sub 'arn:aws:secretsmanager:us-east-1:${AWS::AccountId}:secret:taskmanager/database/shared/*'
                  - !Sub 'arn:aws:secretsmanager:us-east-2:${AWS::AccountId}:secret:taskmanager/database/shared*'

  # Bastion Instance Profile
  BastionInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref BastionRole

  # Aurora Global Database Cluster (Primary in us-east-1)
  AuroraGlobalCluster:
    Type: AWS::RDS::GlobalCluster
    Properties:
      GlobalClusterIdentifier: 'taskmanager-global-cluster'
      Engine: aurora-mysql
      EngineVersion: '5.7.mysql_aurora.2.04.0'
      DeletionProtection: false
  
  AuroraPrimaryCluster:
    Type: AWS::RDS::DBCluster
    Properties:
      GlobalClusterIdentifier: !Ref AuroraGlobalCluster
      Engine: aurora-mysql
      EngineVersion: '5.7.mysql_aurora.2.04.0'
      MasterUsername: taskmanager_admin
      MasterUserPassword: !Ref DatabasePassword
      DatabaseName: taskmanager
      DeletionProtection: false
      ScalingConfiguration:
        MinCapacity: 1
        MaxCapacity: 4
        AutoPause: true
        SecondsUntilAutoPause: 300
    DependsOn: AuroraGlobalCluster

  # Secrets Manager for database credentials
  DatabaseSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: 'taskmanager/database/shared'
      Description: Database credentials for Aurora Serverless Global Database
      SecretString: !Sub |
        {
          "username": "taskmanager_admin",
          "password": "${DatabasePassword}",
          "engine": "aurora-mysql",
          "host": "${AuroraPrimaryCluster.Endpoint.Address}",
          "port": "${AuroraPrimaryCluster.Endpoint.Port}",
          "dbname": "taskmanager",
          "cluster_arn": "${AuroraPrimaryCluster.DBClusterArn}",
          "secret_arn": "arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:taskmanager/database/shared"
        }


  # Note: Cleanup functions removed to avoid layer dependencies
  # The bucket and IAM resources will be cleaned up manually if needed

Outputs:
  SharedLambdaRoleArn:
    Description: 'Shared Lambda execution role ARN'
    Value: !GetAtt SharedLambdaExecutionRole.Arn
    Export:
      Name: 'TaskManager-SharedLambdaRole'

  BastionRoleArn:
    Description: 'Bastion role ARN'
    Value: !GetAtt BastionRole.Arn
    Export:
      Name: 'TaskManager-BastionRole'

  BastionInstanceProfileArn:
    Description: 'Bastion instance profile ARN'
    Value: !Ref BastionInstanceProfile
    Export:
      Name: 'TaskManager-BastionInstanceProfile'

  DatabaseSecretArn:
    Description: 'Database secret ARN'
    Value: !Ref DatabaseSecret
    Export:
      Name: 'TaskManager-DatabaseSecret'


  AuroraGlobalClusterId:
    Description: 'Aurora Global Database cluster identifier'
    Value: !Ref AuroraGlobalCluster
    Export:
      Name: 'TaskManager-AuroraGlobalCluster'

  # Note: Database endpoints will be provided by regional Aurora clusters
  # Each region will have its own Aurora cluster in the global cluster
