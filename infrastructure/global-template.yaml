AWSTemplateFormatVersion: '2010-09-09'
Description: 'TaskManager Global Infrastructure - IAM, S3, Secrets Manager, SNS'

Parameters:
  DatabasePassword:
    Type: String
    NoEcho: true
    MinLength: 8
    Description: 'Password for the Aurora MySQL database'

Resources:

  # IAM Policy for GitHub Actions to manage service-linked roles
  GitHubActionsServiceLinkedRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: 'TaskManager-GitHubActions-ServiceLinkedRole-Policy'
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - iam:GetRole
              - iam:CreateServiceLinkedRole
              - iam:DeleteServiceLinkedRole
            Resource: 'arn:aws:iam::*:role/aws-service-role/*'
          - Effect: Allow
            Action:
              - iam:PassRole
            Resource: 'arn:aws:iam::*:role/TaskManager-*'
      Roles:
        - !Ref SharedLambdaExecutionRole

  # Custom resource to create ECS Service-Linked Role safely
  ECSCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'taskmanager-ecs-role-setup-${AWS::StackName}'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt SharedLambdaExecutionRole.Arn
      Layers:
        - !Ref ECSCleanupLayer
      Code:
        ZipFile: |
          import boto3
          import json
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          iam_client = boto3.client('iam')

          def lambda_handler(event, context):
              try:
                  request_type = event.get('RequestType')

                  logger.info(f"Processing {request_type} for ECS service-linked role")

                  if request_type == 'Create':
                      # Try to create ECS service-linked role if it doesn't exist
                      create_ecs_service_linked_role()

                      # Send success response
                      send_response(event, context, 'SUCCESS', {'Message': 'ECS service-linked role setup complete'})
                  else:
                      # For Update/Delete, just succeed
                      send_response(event, context, 'SUCCESS', {'Message': 'ECS service-linked role unchanged'})

              except Exception as e:
                  logger.error(f"Error processing request: {str(e)}")
                  send_response(event, context, 'SUCCESS', {'Message': f'Handled gracefully: {str(e)}'})

          def create_ecs_service_linked_role():
              try:
                  role_name = 'AWSServiceRoleForECS'
                  service_name = 'ecs.amazonaws.com'

                  # Check if the role already exists
                  try:
                      iam_client.get_role(RoleName=role_name)
                      logger.info(f"ECS service-linked role {role_name} already exists")
                      return
                  except iam_client.exceptions.NoSuchEntityException:
                      logger.info(f"ECS service-linked role {role_name} does not exist, creating...")

                  # Create the service-linked role
                  iam_client.create_service_linked_role(
                      AWSServiceName=service_name,
                      Description='Service-linked role for Amazon ECS'
                  )
                  logger.info(f"Successfully created ECS service-linked role {role_name}")

              except Exception as e:
                  logger.warning(f"Could not create ECS service-linked role: {str(e)}")
                  # Don't fail - the role might already exist or we might not have permissions

          def send_response(event, context, response_status, response_data):
              import urllib3
              import json

              response_url = event.get('ResponseURL')
              if not response_url:
                  return

              response_body = {
                  'Status': response_status,
                  'Reason': response_data.get('Message', 'Operation completed'),
                  'PhysicalResourceId': event.get('PhysicalResourceId', context.log_stream_name),
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              try:
                  response = http.request(
                      'PUT',
                      response_url,
                      body=json_response_body,
                      headers=headers
                  )
                  logger.info(f"Response sent: {response.status}")
              except Exception as e:
                  logger.error(f"Failed to send response: {str(e)}")

  # Lambda Layer for urllib3 dependency
  ECSCleanupLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub 'taskmanager-ecs-cleanup-layer-${AWS::StackName}'
      Description: 'urllib3 dependency for ECS cleanup Lambda'
      Content:
        S3Bucket: !ImportValue 'TaskManager-TemplatesBucket'
        S3Key: 'ecs-cleanup-layer.zip'
      CompatibleRuntimes:
        - python3.9

  # Custom resource to handle ECS service-linked role creation
  ECSRoleSetupResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt ECSCleanupFunction.Arn
    DependsOn: [SharedLambdaExecutionRole, ECSCleanupFunction]

  # Shared Lambda Execution Role
  SharedLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: 'TaskManager-Shared-Lambda-Role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:DescribeSecret
                Resource: !Sub 'arn:aws:secretsmanager:us-east-1:${AWS::AccountId}:secret:taskmanager/database/shared/*'
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:us-east-1:${AWS::AccountId}:*'
        - PolicyName: RDSAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - rds:CreateDatabase
                  - rds:DescribeDBClusters
                  - rds:DescribeDBInstances
                  - rds-data:ExecuteStatement
                  - rds-data:BatchExecuteStatement
                Resource:
                  - !Sub 'arn:aws:rds:us-east-1:${AWS::AccountId}:cluster:taskmanager-*'
                  - !Sub 'arn:aws:rds:us-east-1:${AWS::AccountId}:cluster:taskmanager-global-cluster'

  # Bastion Role
  BastionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: 'TaskManager-Bastion-Role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: SecretsManagerRead
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Sub 'arn:aws:secretsmanager:us-east-1:${AWS::AccountId}:secret:taskmanager/database/shared/*'

  # Bastion Instance Profile
  BastionInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref BastionRole

  # Aurora Global Database Cluster (Primary in us-east-1)
  AuroraGlobalCluster:
    Type: AWS::RDS::GlobalCluster
    Properties:
      GlobalClusterIdentifier: 'taskmanager-global-cluster'
      Engine: aurora-mysql
      EngineVersion: '8.0.mysql_aurora.3.05.2'
      DatabaseName: 'taskmanager'
      MasterUsername: 'taskmanager_admin'
      MasterUserPassword: !Ref DatabasePassword
      DeletionProtection: false

  # Secrets Manager for database credentials
  DatabaseSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: 'taskmanager/database/shared'
      Description: Database credentials for Aurora Global Database
      SecretString: !Sub |
        {
          "username": "taskmanager_admin",
          "password": "${DatabasePassword}",
          "engine": "aurora-mysql",
          "host": "PLACEHOLDER",
          "port": 3306,
          "dbname": "taskmanager",
          "cluster_arn": "${AuroraGlobalCluster}",
          "secret_arn": "${AWS::StackName}"
        }

  # SNS Topic for Deployment Notifications
  DeploymentNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: 'TaskManager-Deployment-Notifications'
      DisplayName: 'TaskManager Deployment Notifications'
      Subscription:
        - Protocol: sms
          Endpoint: '+17034740324'

  # SNS Topic Policy
  DeploymentNotificationTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics:
        - !Ref DeploymentNotificationTopic
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action:
              - sns:Publish
              - sns:Subscribe
            Resource: !Ref DeploymentNotificationTopic

  # Note: Cleanup functions removed to avoid layer dependencies
  # The bucket and IAM resources will be cleaned up manually if needed

Outputs:
  SharedLambdaRoleArn:
    Description: 'Shared Lambda execution role ARN'
    Value: !GetAtt SharedLambdaExecutionRole.Arn
    Export:
      Name: 'TaskManager-SharedLambdaRole'

  BastionRoleArn:
    Description: 'Bastion role ARN'
    Value: !GetAtt BastionRole.Arn
    Export:
      Name: 'TaskManager-BastionRole'

  BastionInstanceProfileArn:
    Description: 'Bastion instance profile ARN'
    Value: !Ref BastionInstanceProfile
    Export:
      Name: 'TaskManager-BastionInstanceProfile'

  DatabaseSecretArn:
    Description: 'Database secret ARN'
    Value: !Ref DatabaseSecret
    Export:
      Name: 'TaskManager-DatabaseSecret'

  DeploymentNotificationTopicArn:
    Description: 'SNS topic ARN for deployment notifications'
    Value: !Ref DeploymentNotificationTopic
    Export:
      Name: 'TaskManager-DeploymentNotificationTopic'

  AuroraGlobalClusterId:
    Description: 'Aurora Global Database cluster identifier'
    Value: !Ref AuroraGlobalCluster
    Export:
      Name: 'TaskManager-AuroraGlobalCluster'

  # Note: Database endpoints will be provided by regional Aurora clusters
  # Each region will have its own Aurora cluster in the global cluster
