AWSTemplateFormatVersion: "2010-09-09"
Description: "GitHub Actions IAM User and Permissions Setup"

Parameters:
  TemplatesBucketName:
    Type: String
    Description: "Name of the S3 bucket for CloudFormation templates (must already exist or be created separately)"

  RetentionDays:
    Type: Number
    Default: 7
    Description: "Number of days to retain CloudWatch logs"

  GitHubActionsUserName:
    Type: String
    Default: ""
    Description: "Existing GitHub Actions IAM user name (leave empty to create new user)"

Conditions:
  CreateGitHubActionsUser: !Equals [!Ref GitHubActionsUserName, ""]

Resources:
  # IAM User for GitHub Actions (only created if GitHubActionsUserName is empty)
  GitHubActionsUser:
    Type: AWS::IAM::User
    Condition: CreateGitHubActionsUser

  # Custom IAM Policy with specific permissions
  DeploymentPolicy:
    Type: AWS::IAM::Policy
    Condition: CreateGitHubActionsUser
    Properties:
      PolicyName: !Sub "DeploymentPolicy-${AWS::Region}"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          # Core AWS service permissions
          - Effect: Allow
            Action:
              - cloudformation:*
              - lambda:*
              - apigateway:*
              - rds:*
              - ec2:*
              - secretsmanager:*
              - logs:*
              - cloudwatch:*
              - s3:*
              - sns:*
              - ecs:*
              - ecr:*
              - elasticloadbalancing:*
              - acm:*
              - route53:*
              - iam:*
              - ssm:GetParameter
              - ssm:GetParameters
              - config:*
            Resource: "*"

          # Service-linked role creation
          - Effect: Allow
            Action:
              - iam:CreateServiceLinkedRole
            Resource: "*"
            Condition:
              StringEquals:
                iam:AWSServiceName:
                  - "elasticloadbalancing.amazonaws.com"
                  - "ecs.amazonaws.com"

          # KMS permissions for Aurora encryption
          - Effect: Allow
            Action:
              - kms:CreateKey
              - kms:DescribeKey
              - kms:CreateGrant
              - kms:Decrypt
              - kms:Encrypt
              - kms:GenerateDataKey
              - kms:ReEncryptFrom
              - kms:ReEncryptTo
              - kms:RetireGrant
              - kms:CreateAlias
              - kms:DeleteAlias
              - kms:UpdateAlias
              - kms:ListAliases
              - kms:ListGrants
              - kms:RevokeGrant
              - kms:PutKeyPolicy
              - kms:ReplicateKey
              - kms:ScheduleKeyDeletion
              - kms:GetKeyPolicy
            Resource: "*"

          # Tagging permissions for all resources
          - Effect: Allow
            Action:
              - ec2:CreateTags
              - ec2:DeleteTags
              - ec2:DescribeTags
              - rds:AddTagsToResource
              - rds:RemoveTagsFromResource
              - rds:DescribeDBInstances
              - rds:DescribeDBClusters
              - lambda:TagResource
              - lambda:UntagResource
              - lambda:ListTags
              - logs:TagLogGroup
              - logs:UntagLogGroup
              - logs:ListTagsLogGroup
              - ecr:TagResource
              - ecr:UntagResource
              - ecr:ListTagsForResource
              - ecs:TagResource
              - ecs:UntagResource
              - ecs:ListTagsForResource
              - elasticloadbalancing:AddTags
              - elasticloadbalancing:RemoveTags
              - elasticloadbalancing:DescribeTags
              - secretsmanager:TagResource
              - secretsmanager:UntagResource
              - secretsmanager:DescribeSecret
              - kms:TagResource
              - kms:UntagResource
              - kms:ListResourceTags
              - s3:PutBucketTagging
              - s3:GetBucketTagging
              - s3:DeleteBucketTagging
              - route53:ChangeTagsForResource
              - route53:ListTagsForResource
              - acm:AddTagsToCertificate
              - acm:RemoveTagsFromCertificate
              - acm:ListTagsForCertificate
              - cloudwatch:TagResource
              - cloudwatch:UntagResource
              - cloudwatch:ListTagsForResource
            Resource: "*"

          # STS permissions
          - Effect: Allow
            Action:
              - sts:GetCallerIdentity
              - sts:AssumeRole
            Resource: "*"
      Users:
        - !If
          - CreateGitHubActionsUser
          - !Ref GitHubActionsUser
          - !Ref GitHubActionsUserName

  # Access Key for GitHub Actions
  GitHubActionsAccessKey:
    Type: AWS::IAM::AccessKey
    Condition: CreateGitHubActionsUser
    Properties:
      UserName: !If
        - CreateGitHubActionsUser
        - !Ref GitHubActionsUser
        - !Ref GitHubActionsUserName

  # S3 Bucket Policy for CloudFormation Access (bucket must exist)
  TemplatesBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref TemplatesBucketName
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowCloudFormationAccess
            Effect: Allow
            Principal:
              Service: cloudformation.amazonaws.com
            Action:
              - s3:GetObject
            Resource: !Sub "arn:aws:s3:::${TemplatesBucketName}/*"
          - Sid: AllowGitHubActionsFullAccess
            Effect: Allow
            Principal:
              AWS: !If
                - CreateGitHubActionsUser
                - !GetAtt GitHubActionsUser.Arn
                - !Sub "arn:aws:iam::${AWS::AccountId}:user/${GitHubActionsUserName}"
            Action:
              - s3:*
            Resource:
              - !Sub "arn:aws:s3:::${TemplatesBucketName}"
              - !Sub "arn:aws:s3:::${TemplatesBucketName}/*"

  # ECR Repository for Web Application
  WebECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      ImageScanningConfiguration:
        ScanOnPush: true
      ImageTagMutability: MUTABLE
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Expire untagged images older than 3 days",
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "sinceImagePushed",
                  "countUnit": "days",
                  "countNumber": 3
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }

  # API Gateway CloudWatch Logs Role
  ApiGatewayCloudWatchLogsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "ApiGatewayCloudWatchLogsPolicy-${AWS::Region}"
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                  - logs:FilterLogEvents
                  - logs:GetLogEvents
                Resource: "*"

  # API Gateway Account Configuration
  ApiGatewayAccount:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: !GetAtt ApiGatewayCloudWatchLogsRole.Arn

  # Lambda function for Config rule evaluation and remediation
  LogRetentionConfigFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt ConfigRuleRole.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          from datetime import datetime

          def lambda_handler(event, context):
              print(f"Received event: {json.dumps(event)}")

              # Check if this is a remediation call
              if 'RetentionDays' in event:
                  return handle_remediation(event)

              # Otherwise, handle Config evaluation
              return handle_evaluation(event)

          def handle_evaluation(event):
              config_client = boto3.client('config')
              logs_client = boto3.client('logs')

              retention_days = int(os.environ['RETENTION_DAYS'])

              # Get the log group from the configuration item
              invoking_event = json.loads(event['invokingEvent'])
              configuration_item = invoking_event['configurationItem']

              log_group_name = configuration_item['resourceName']

              # Evaluate compliance
              try:
                  response = logs_client.describe_log_groups(
                      logGroupNamePrefix=log_group_name
                  )

                  if response['logGroups']:
                      log_group = response['logGroups'][0]
                      current_retention = log_group.get('retentionInDays')

                      if current_retention != retention_days:
                          # Non-compliant
                          return {
                              'ComplianceType': 'NON_COMPLIANT',
                              'Annotation': f'Log group retention is {current_retention}, should be {retention_days}'
                          }
                      else:
                          return {'ComplianceType': 'COMPLIANT'}

              except Exception as e:
                  print(f"Error evaluating log group {log_group_name}: {str(e)}")
                  return {
                      'ComplianceType': 'NON_COMPLIANT',
                      'Annotation': f'Error evaluating log group: {str(e)}'
                  }

              return {'ComplianceType': 'NOT_APPLICABLE'}

          def handle_remediation(event):
              logs_client = boto3.client('logs')

              log_group_name = event.get('LogGroupName')
              retention_days = int(event['RetentionDays'])

              if not log_group_name:
                  raise ValueError("LogGroupName not provided in remediation event")

              try:
                  logs_client.put_retention_policy(
                      logGroupName=log_group_name,
                      retentionInDays=retention_days
                  )
                  print(f"Set retention to {retention_days} days for {log_group_name}")
                  return {'status': 'SUCCESS'}
              except Exception as e:
                  print(f"Error setting retention for {log_group_name}: {str(e)}")
                  raise e
      Environment:
        Variables:
          RETENTION_DAYS: !Ref RetentionDays

  # IAM role for Config rule Lambda
  ConfigRuleRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub "ConfigRulePolicy-${AWS::Region}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - config:PutEvaluations
                  - logs:DescribeLogGroups
                  - logs:PutRetentionPolicy
                Resource: "*"

  # Config Rule for log group retention
  LogRetentionConfigRule:
    Type: AWS::Config::ConfigRule
    Properties:
      Description: "Checks that CloudWatch log groups have appropriate retention settings"
      Scope:
        ComplianceResourceTypes:
          - AWS::Logs::LogGroup
      Source:
        Owner: CUSTOM_LAMBDA
        SourceIdentifier: !GetAtt LogRetentionConfigFunction.Arn
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification

  # SSM Automation Document for remediation
  LogRetentionRemediationDocument:
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Automation
      Content:
        schemaVersion: "0.3"
        assumeRole: "{{AutomationAssumeRole}}"
        parameters:
          LogGroupName:
            type: String
            description: The name of the log group to remediate
          RetentionDays:
            type: String
            description: The retention period in days
          AutomationAssumeRole:
            type: String
            description: The ARN of the role that allows Automation to perform actions
        mainSteps:
          - name: InvokeLambdaFunction
            action: aws:invokeLambdaFunction
            inputs:
              FunctionName: !Ref LogRetentionConfigFunction
              Payload: |
                {
                  "LogGroupName": "{{LogGroupName}}",
                  "RetentionDays": "{{RetentionDays}}"
                }

  # IAM role for SSM Automation
  SSMAutomationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ssm.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole
      Policies:
        - PolicyName: !Sub "SSMAutomationLambdaInvoke-${AWS::Region}"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt LogRetentionConfigFunction.Arn

  # Remediation configuration using SSM document
  LogRetentionRemediation:
    Type: AWS::Config::RemediationConfiguration
    Properties:
      ConfigRuleName: !Ref LogRetentionConfigRule
      TargetId: !Ref LogRetentionRemediationDocument
      TargetType: SSM_DOCUMENT
      Parameters:
        LogGroupName:
          ResourceValue:
            Value: RESOURCE_ID
        RetentionDays:
          StaticValue:
            Values:
              - !Ref RetentionDays
        AutomationAssumeRole:
          StaticValue:
            Values:
              - !GetAtt SSMAutomationRole.Arn
      Automatic: true
      MaximumAutomaticAttempts: 5
      RetryAttemptSeconds: 60

  # Permission for Config to invoke Lambda
  ConfigInvokeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LogRetentionConfigFunction
      Action: lambda:InvokeFunction
      Principal: config.amazonaws.com
      SourceAccount: !Ref AWS::AccountId

Outputs:
  UserName:
    Description: "IAM User name for GitHub Actions"
    Value: !If
      - CreateGitHubActionsUser
      - !Ref GitHubActionsUser
      - !Ref GitHubActionsUserName
    Export:
      Name: GitHubActionsUser

  AccessKeyId:
    Description: "Access Key ID for GitHub Actions (add to GitHub secrets)"
    Condition: CreateGitHubActionsUser
    Value: !Ref GitHubActionsAccessKey

  SecretAccessKey:
    Description: "Secret Access Key for GitHub Actions (add to GitHub secrets)"
    Condition: CreateGitHubActionsUser
    Value: !GetAtt GitHubActionsAccessKey.SecretAccessKey

  UserArn:
    Description: "IAM User ARN"
    Value: !If
      - CreateGitHubActionsUser
      - !GetAtt GitHubActionsUser.Arn
      - !Sub "arn:aws:iam::${AWS::AccountId}:user/${GitHubActionsUserName}"
    Export:
      Name: GitHubActionsUserArn

  PolicyArn:
    Description: "Custom policy ARN"
    Condition: CreateGitHubActionsUser
    Value: !Ref DeploymentPolicy
    Export:
      Name: DeploymentPolicy

  TemplatesBucketName:
    Description: "S3 bucket name for CloudFormation templates"
    Value: !Ref TemplatesBucketName
    Export:
      Name: TemplatesBucketName

  WebECRRepositoryName:
    Description: "ECR repository name for web application"
    Value: !Ref WebECRRepository
    Export:
      Name: WebECRRepository

  WebECRRepositoryUri:
    Description: "ECR repository URI for web application"
    Value: !GetAtt WebECRRepository.RepositoryUri
    Export:
      Name: WebECRRepositoryUri

  ApiGatewayCloudWatchLogsRoleArn:
    Description: "API Gateway CloudWatch Logs role ARN"
    Value: !GetAtt ApiGatewayCloudWatchLogsRole.Arn
    Export:
      Name: ApiGatewayCloudWatchLogsRoleArn

  SetupInstructions:
    Description: "Instructions for GitHub Secrets setup"
    Condition: CreateGitHubActionsUser
    Value: !Sub |
      Add these to your GitHub repository secrets:
      AWS_ACCESS_KEY_ID=${GitHubActionsAccessKey}
      AWS_SECRET_ACCESS_KEY=${GitHubActionsAccessKey.SecretAccessKey}

      Also add:
      DATABASE_PASSWORD=your-secure-password
      GOOGLE_CLIENT_ID=your-google-client-id
      GOOGLE_CLIENT_SECRET=your-google-client-secret

      IMPORTANT: Ensure the S3 bucket '${TemplatesBucketName}' exists and is configured with:
      - Versioning enabled
      - Server-side encryption (SSE-S3 or SSE-KMS)
      - Public access blocked
      - Appropriate bucket policies for CloudFormation and GitHub Actions access
