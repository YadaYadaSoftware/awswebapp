AWSTemplateFormatVersion: "2010-09-09"
Description: "TaskManager Regional Infrastructure - VPC, RDS, ECS, Bastion Host"

Parameters:
  DatabasePassword:
    Type: String
    NoEcho: true
    MinLength: 8
    Description: "Password for the Aurora MySQL database"

  EngineVersion:
    Type: String
    Description: "Aurora MySQL engine version for the regional cluster"

  BastionPublicKeyMaterial:
    Type: String
    Description: "Public key material for bastion SSH access (generate locally with ssh-keygen and paste the .pub content here)"
    Default: "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCuSPS013ezN5lbrX/yOgu2d5n+97vzyj0P7oD2n5mCyblEG184U6r0LOu+DWURveDTLOtBEUCa5cCfnW3vTd6A25t9fHJFB0V+DuOCQ+tMVLxvs3yu61Cmz4ChNEK/qUX9YtpDwXJP1SmnKUPJOnFAfUwyClBqbQjd6rkyYYKmuRLD3llEXZDO/GwLpWO3KvNWLYJnz+MAJL4LU1JXimYfJqVmd3PUGUyUI55d5lqfZYCGxwzb3Eg31bZ4ljf0vBT6ztgwrVvBvpRlkmTRqcqvypS/3zDd6USmf8rLOB5VwnFw+f4o88K1x3O5iqZrRxApjdlLA8IDIH7uFP89KjKX 17034@DESKTOP-3BGTTVG"

  SharedLambdaRoleArn:
    Type: String
    Description: "ARN of the shared Lambda execution role from global stack"

  BastionRoleArn:
    Type: String
    Description: "ARN of the bastion role from global stack"

  DatabaseSecretArn:
    Type: String
    Description: "ARN of the database secret from global stack"

  BastionInstanceProfileArn:
    Type: String
    Description: "ARN of the bastion instance profile from global stack"

  AuroraGlobalClusterId:
    Type: String
    Description: "ID of the Aurora global cluster from global stack"

  AuroraKmsKeyArn:
    Type: String
    Description: "ARN of the KMS key used by the Aurora global cluster"

  # Parameters from regional-db.yaml outputs
  VPCId:
    Type: String
    Description: "VPC ID from regional-db stack"

  PrivateSubnet1Id:
    Type: String
    Description: "Private subnet 1 ID from regional-db stack"

  PrivateSubnet2Id:
    Type: String
    Description: "Private subnet 2 ID from regional-db stack"

  PublicSubnet1Id:
    Type: String
    Description: "Public subnet 1 ID from regional-db stack"

  PublicSubnet2Id:
    Type: String
    Description: "Public subnet 2 ID from regional-db stack"

  LambdaSecurityGroupId:
    Type: String
    Description: "Lambda security group ID from regional-db stack"

  RDSSecurityGroupId:
    Type: String
    Description: "RDS security group ID from regional-db stack"

  BastionSecurityGroupId:
    Type: String
    Description: "Bastion security group ID from regional-db stack"

  ALBSecurityGroupId:
    Type: String
    Description: "ALB security group ID from regional-db stack"

  ECSTaskSecurityGroupId:
    Type: String
    Description: "ECS task security group ID from regional-db stack"

  DatabaseEndpoint:
    Type: String
    Description: "Database endpoint from regional-db stack"

  DatabaseReaderEndpoint:
    Type: String
    Description: "Database reader endpoint from regional-db stack"

  RegionalDatabaseSecretArn:
    Type: String
    Description: "Database secret ARN from regional-db stack"

Resources:

  # ECR Repository for Web Application
  WebECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: "taskmanager-web"
      ImageScanningConfiguration:
        ScanOnPush: true
      ImageTagMutability: "MUTABLE"
      Tags:
        - Key: Name
          Value: "TaskManager-Web-ECR"
        - Key: Purpose
          Value: "Container Registry"


  # Lambda Layer for urllib3 dependency
  ECRCleanupLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub "taskmanager-ecr-cleanup-layer-${AWS::StackName}"
      Description: "urllib3 dependency for ECR cleanup Lambda"
      Content:
        S3Bucket: !Sub "taskmanager-templates-bucket-${AWS::Region}"
        S3Key: "ecr-cleanup-layer.zip"
      CompatibleRuntimes:
        - python3.9

  # Lambda function to clean up ECR images on stack deletion
  ECRCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "taskmanager-ecr-cleanup-${AWS::StackName}"
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !Ref SharedLambdaRoleArn
      Layers:
        - !Ref ECRCleanupLayer
      Code:
        ZipFile: |
          import boto3
          import json
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          ecr_client = boto3.client('ecr')

          def lambda_handler(event, context):
              try:
                  request_type = event.get('RequestType')
                  repository_name = event.get('ResourceProperties', {}).get('RepositoryName')

                  if not repository_name:
                      raise ValueError("RepositoryName is required")

                  logger.info(f"Processing {request_type} for repository: {repository_name}")

                  if request_type == 'Delete':
                      # Delete all images from the repository
                      cleanup_ecr_repository(repository_name)

                      # Send success response
                      send_response(event, context, 'SUCCESS', {'Message': f'Successfully cleaned up repository {repository_name}'})
                  else:
                      # For Create/Update, just succeed
                      send_response(event, context, 'SUCCESS', {'Message': f'Repository {repository_name} ready'})

              except Exception as e:
                  logger.error(f"Error processing request: {str(e)}")
                  send_response(event, context, 'FAILED', {'Error': str(e)})

          def cleanup_ecr_repository(repository_name):
              try:
                  # List all images in the repository
                  paginator = ecr_client.get_paginator('list_images')
                  image_ids = []

                  for page in paginator.paginate(repositoryName=repository_name):
                      for image_id in page['imageIds']:
                          image_ids.append(image_id)

                  if not image_ids:
                      logger.info(f"No images found in repository {repository_name}")
                      return

                  logger.info(f"Found {len(image_ids)} images to delete from {repository_name}")

                  # Delete images in batches (ECR allows max 100 per request)
                  batch_size = 100
                  for i in range(0, len(image_ids), batch_size):
                      batch = image_ids[i:i + batch_size]
                      ecr_client.batch_delete_image(
                          repositoryName=repository_name,
                          imageIds=batch
                      )
                      logger.info(f"Deleted batch of {len(batch)} images")

                  logger.info(f"Successfully cleaned up all images from {repository_name}")

              except ecr_client.exceptions.RepositoryNotFoundException:
                  logger.info(f"Repository {repository_name} not found, nothing to clean up")
              except Exception as e:
                  logger.error(f"Error cleaning up repository {repository_name}: {str(e)}")
                  raise

          def send_response(event, context, response_status, response_data):
              import urllib3
              import json

              response_url = event.get('ResponseURL')
              if not response_url:
                  return

              response_body = {
                  'Status': response_status,
                  'Reason': response_data.get('Message', 'Operation completed'),
                  'PhysicalResourceId': event.get('PhysicalResourceId', context.log_stream_name),
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              try:
                  response = http.request(
                      'PUT',
                      response_url,
                      body=json_response_body,
                      headers=headers
                  )
                  logger.info(f"Response sent: {response.status}")
              except Exception as e:
                  logger.error(f"Failed to send response: {str(e)}")

  # Lambda function to clean up security groups on stack deletion
  SecurityGroupCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "taskmanager-sg-cleanup-${AWS::StackName}"
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !Ref SharedLambdaRoleArn
      Layers:
        - !Ref SecurityGroupCleanupLayer
      Code:
        ZipFile: |
          import boto3
          import json
          import logging
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          ec2_client = boto3.client('ec2')

          def lambda_handler(event, context):
              try:
                  request_type = event.get('RequestType')
                  security_group_ids = event.get('ResourceProperties', {}).get('SecurityGroupIds', [])

                  if not security_group_ids:
                      raise ValueError("SecurityGroupIds is required")

                  logger.info(f"Processing {request_type} for security groups: {security_group_ids}")

                  if request_type == 'Delete':
                      # Clean up security groups
                      cleanup_security_groups(security_group_ids)

                      # Send success response
                      send_response(event, context, 'SUCCESS', {'Message': f'Successfully cleaned up security groups {security_group_ids}'})
                  else:
                      # For Create/Update, just succeed
                      send_response(event, context, 'SUCCESS', {'Message': f'Security groups {security_group_ids} ready'})

              except Exception as e:
                  logger.error(f"Error processing request: {str(e)}")
                  send_response(event, context, 'FAILED', {'Error': str(e)})

          def cleanup_security_groups(security_group_ids):
              try:
                  logger.info(f"Cleaning up security groups: {security_group_ids}")

                  for sg_id in security_group_ids:
                      try:
                          # Get current security group rules
                          response = ec2_client.describe_security_groups(GroupIds=[sg_id])
                          sg = response['SecurityGroups'][0]

                          # Remove all ingress rules
                          if sg.get('IpPermissions'):
                              logger.info(f"Removing ingress rules from {sg_id}")
                              ec2_client.revoke_security_group_ingress(
                                  GroupId=sg_id,
                                  IpPermissions=sg['IpPermissions']
                              )

                          # Remove all egress rules (except the default allow all outbound)
                          if sg.get('IpPermissionsEgress'):
                              # Filter out the default egress rule
                              egress_rules = []
                              for rule in sg['IpPermissionsEgress']:
                                  # Skip the default "allow all outbound" rule
                                  if not (rule.get('IpProtocol') == '-1' and
                                         rule.get('IpRanges', [{}])[0].get('CidrIp') == '0.0.0.0/0'):
                                      egress_rules.append(rule)

                              if egress_rules:
                                  logger.info(f"Removing egress rules from {sg_id}")
                                  ec2_client.revoke_security_group_egress(
                                      GroupId=sg_id,
                                      IpPermissions=egress_rules
                                  )

                          logger.info(f"Successfully cleaned up security group: {sg_id}")

                      except ec2_client.exceptions.ClientError as e:
                          if 'InvalidGroupId.NotFound' in str(e):
                              logger.info(f"Security group {sg_id} not found, already deleted")
                          else:
                              logger.error(f"Error cleaning up security group {sg_id}: {str(e)}")
                              raise

                  logger.info(f"Successfully cleaned up all security groups: {security_group_ids}")

              except Exception as e:
                  logger.error(f"Error cleaning up security groups {security_group_ids}: {str(e)}")
                  raise

          def send_response(event, context, response_status, response_data):
              import urllib3
              import json

              response_url = event.get('ResponseURL')
              if not response_url:
                  return

              response_body = {
                  'Status': response_status,
                  'Reason': response_data.get('Message', 'Operation completed'),
                  'PhysicalResourceId': event.get('PhysicalResourceId', context.log_stream_name),
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              try:
                  response = http.request(
                      'PUT',
                      response_url,
                      body=json_response_body,
                      headers=headers
                  )
                  logger.info(f"Response sent: {response.status}")
              except Exception as e:
                  logger.error(f"Failed to send response: {str(e)}")

  # Lambda Layer for urllib3 dependency
  SecurityGroupCleanupLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub "taskmanager-sg-cleanup-layer-${AWS::StackName}"
      Description: "urllib3 dependency for Security Group cleanup Lambda"
      Content:
        S3Bucket: !Sub "taskmanager-templates-bucket-${AWS::Region}"
        S3Key: "sg-cleanup-layer.zip"
      CompatibleRuntimes:
        - python3.9

  # Custom resource to trigger ECR cleanup on stack deletion
  ECRCleanupResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt ECRCleanupFunction.Arn
      RepositoryName: "taskmanager-web"
    DependsOn: WebECRRepository

  # Custom resource to trigger Security Group cleanup on stack deletion
  SecurityGroupCleanupResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt SecurityGroupCleanupFunction.Arn
      SecurityGroupIds:
        - !Ref LambdaSecurityGroupId
        - !Ref RDSSecurityGroupId
        - !Ref BastionSecurityGroupId
        - !Ref ALBSecurityGroupId
        - !Ref ECSTaskSecurityGroupId
    DependsOn:
      [
        SecurityGroupCleanupFunction,
      ]

  # Note: Bastion IAM role cleanup is handled by the global stack's IAM cleanup function
  # The BastionRole is created in the global stack and cleaned up there

  # ECS Cluster
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: "TaskManager-Cluster"
      Tags:
        - Key: Name
          Value: "TaskManager-ECS-Cluster"
        - Key: Purpose
          Value: "Regional Infrastructure"

  # SSH Key Pair for Bastion
  BastionKeyPair:
    Type: AWS::EC2::KeyPair
    Properties:
      KeyName: !Sub "taskmanager-bastion-key-${AWS::StackName}-updated"
      KeyType: rsa
      KeyFormat: pem
      PublicKeyMaterial: !Ref BastionPublicKeyMaterial

  # Bastion Instance Profile (using global)

  BastionHost:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: ami-0c02fb55956c7d316 # Amazon Linux 2023
      InstanceType: t3.micro
      SubnetId: !Ref PublicSubnet1Id
      SecurityGroupIds:
        - !Ref BastionSecurityGroupId
      IamInstanceProfile: !Ref BastionInstanceProfileArn
      KeyName: !Ref BastionKeyPair
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y mysql

          # Create connection helper script
          cat > /home/ec2-user/connect-to-db.sh << 'EOF'
          #!/bin/bash
          echo "TaskManager Aurora MySQL Database Connection Helper"
          echo "Aurora Endpoint: ${DatabaseEndpoint}"
          echo ""
          echo "To connect to Aurora MySQL database:"
          echo "mysql -h ${DatabaseEndpoint} -u taskmanager_admin -p"
          echo ""
          echo "Available databases:"
          echo "- Connect and run: SHOW DATABASES; to list all databases"
          echo "- Each branch creates its own database (e.g., taskmanager_main, taskmanager_feature1)"
          echo ""
          echo "Note: This is a cluster in the Aurora Global Database"
          EOF

          chmod +x /home/ec2-user/connect-to-db.sh
          chown ec2-user:ec2-user /home/ec2-user/connect-to-db.sh
      Tags:
        - Key: Name
          Value: "TaskManager-Bastion"
        - Key: Purpose
          Value: "Regional Infrastructure"

Outputs:
   VPCId:
     Description: "VPC ID for branch applications"
     Value: !Ref VPCId
     Export:
       Name: "TaskManager-VPC"

   PrivateSubnet1Id:
     Description: "Private subnet 1 ID"
     Value: !Ref PrivateSubnet1Id
     Export:
       Name: "TaskManager-PrivateSubnet1"

   PrivateSubnet2Id:
     Description: "Private subnet 2 ID"
     Value: !Ref PrivateSubnet2Id
     Export:
       Name: "TaskManager-PrivateSubnet2"

   PublicSubnet1Id:
     Description: "Public subnet 1 ID"
     Value: !Ref PublicSubnet1Id
     Export:
       Name: "TaskManager-PublicSubnet1"

   PublicSubnet2Id:
     Description: "Public subnet 2 ID"
     Value: !Ref PublicSubnet2Id
     Export:
       Name: "TaskManager-PublicSubnet2"

   LambdaSecurityGroupId:
     Description: "Security group for Lambda functions"
     Value: !Ref LambdaSecurityGroupId
     Export:
       Name: "TaskManager-LambdaSecurityGroup"

   RDSSecurityGroupId:
     Description: "Security group for RDS access"
     Value: !Ref RDSSecurityGroupId
     Export:
       Name: "TaskManager-RDSSecurityGroup"

   DatabaseEndpoint:
     Description: "Aurora MySQL cluster endpoint"
     Value: !Ref DatabaseEndpoint
     Export:
       Name: "TaskManager-DatabaseEndpoint"

   DatabaseReaderEndpoint:
     Description: "Aurora MySQL reader endpoint"
     Value: !Ref DatabaseReaderEndpoint
     Export:
       Name: "TaskManager-DatabaseReaderEndpoint"

   DatabaseSecretArn:
     Description: "Database secret ARN"
     Value: !Ref RegionalDatabaseSecretArn
     Export:
       Name: "TaskManager-DatabaseSecret"

   BastionHostIP:
     Description: "Bastion host public IP address"
     Value: !GetAtt BastionHost.PublicIp
     Export:
       Name: "TaskManager-BastionIP"

   BastionHostId:
     Description: "Bastion host instance ID"
     Value: !Ref BastionHost
     Export:
       Name: "TaskManager-BastionHostId"

   BastionKeyPairName:
     Description: "Name of the SSH key pair for bastion access"
     Value: !Ref BastionKeyPair
     Export:
       Name: "TaskManager-BastionKeyPairName"

   DatabaseTunnelCommand:
     Description: "SSH tunnel command for Aurora MySQL database access"
     Value: !Sub
       - "ssh -i your-key.pem -L 3306:${DbEndpoint}:3306 ec2-user@${BastionIp}"
       - DbEndpoint: !Ref DatabaseEndpoint
         BastionIp: !GetAtt BastionHost.PublicIp
     Export:
       Name: "TaskManager-DatabaseTunnelCommand"

   ECSClusterName:
     Description: "ECS cluster name"
     Value: !Ref ECSCluster
     Export:
       Name: "TaskManager-ECSCluster"

   ALBSecurityGroupId:
     Description: "Security group for Application Load Balancer"
     Value: !Ref ALBSecurityGroupId
     Export:
       Name: "TaskManager-ALBSecurityGroup"

   ECSTaskSecurityGroupId:
     Description: "Security group for ECS tasks"
     Value: !Ref ECSTaskSecurityGroupId
     Export:
       Name: "TaskManager-ECSTaskSecurityGroup"

  WebECRRepositoryUri:
    Description: "ECR repository URI for web application"
    Value: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/taskmanager-web"
    Export:
      Name: "TaskManager-WebECRRepositoryUri"
