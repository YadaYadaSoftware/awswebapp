# TaskManager CI/CD Pipeline - Shared Infrastructure + Branch Applications

name: Deploy Everything

on:
  push:
  pull_request:

env:
  AWS_REGION_SECONDARY: us-west-2
  AWS_REGION_PRIMARY: us-east-1
  ENGINE_VERSION: 8.0.mysql_aurora.3.10.0

jobs:
  get-branch-name:
    name: Get Branch Name
    runs-on: ubuntu-latest
    outputs:
      branch-name: ${{ steps.get-branch.outputs.branch-name }}
    steps:
    - name: Get branch name
      id: get-branch
      run: |
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT

  build:
    name: Build and Test Applications
    runs-on: ubuntu-latest
    outputs:
      semVer: ${{ steps.gitversion.outputs.semVer }}
      customVersion: ${{ steps.custom-version.outputs.custom-version }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x

    - name: Setup GitVersion
      uses: gittools/actions/gitversion/setup@v0
      with:
        versionSpec: '5.x'

    - name: Unshallow repository if needed
      run: |
        if [ "$(git rev-parse --is-shallow-repository)" = "true" ]; then
          echo "Repository is shallow, unshallowing..."
          git fetch --unshallow
        else
          echo "Repository is not shallow"
        fi

    - name: Determine Version
      id: gitversion
      uses: gittools/actions/gitversion/execute@v0
      with:
        useConfigFile: true

    - name: Set Custom Version
      id: custom-version
      run: |
        MAJOR=${{ steps.gitversion.outputs.major }}
        MINOR=${{ steps.gitversion.outputs.minor }}
        PATCH=${{ steps.gitversion.outputs.patch }}
        BUILD=${{ steps.gitversion.outputs.buildMetaData }}
        CUSTOM_VERSION="$MAJOR.$MINOR.$PATCH.$BUILD"
        echo "custom-version=$CUSTOM_VERSION"
        echo "custom-version=$CUSTOM_VERSION" >> $GITHUB_OUTPUT
        echo "Using custom version: $CUSTOM_VERSION"

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore

    - name: Build
      run: |
        echo "Building with version: ${{ steps.custom-version.outputs.custom-version }}"
        dotnet build --no-restore --configuration Release /p:Version=${{ steps.custom-version.outputs.custom-version }} /p:AssemblyVersion=${{ steps.gitversion.outputs.assemblySemVer }} /p:FileVersion=${{ steps.gitversion.outputs.assemblySemVer }}

    - name: Test
      run: dotnet test --no-build --verbosity normal --configuration Release


    - name: Publish Web for Container
      run: |
        echo "Publishing Web with version: ${{ steps.custom-version.outputs.custom-version }}"
        dotnet publish src/TaskManager.Web2/TaskManager.Web2.csproj --configuration Release --output ./publish/web --runtime linux-x64 --self-contained false /p:Version=${{ steps.custom-version.outputs.custom-version }} /p:AssemblyVersion=${{ steps.gitversion.outputs.assemblySemVer }}



    - name: Create MySQL Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install PyMySQL (pure Python MySQL driver)
        pip install PyMySQL -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r mysql-layer.zip python/

        echo "MySQL layer created successfully"

    - name: Upload MySQL Layer
      uses: actions/upload-artifact@v4
      with:
        name: mysql-layer-package
        path: mysql-layer.zip
  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: [build, get-branch-name]
    concurrency:
      group: deploy-${{ matrix.region }}-${{ needs.get-branch-name.outputs.branch-name }}
      cancel-in-progress: false
    strategy:
      matrix:
        include:
          - region: us-east-1
            is_primary: "true"
            deploy: true
          - region: us-west-2
            is_primary: "false"
            deploy: ${{ contains(fromJson('["app","beta","dev"]'), needs.get-branch-name.outputs.branch-name) }}
      max-parallel: 1
    steps:
    - name: Checkout code
      if: matrix.deploy
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Determine deployment type
      if: matrix.deploy
      id: deployment-type
      run: |
        BRANCH_NAME="${{ needs.get-branch-name.outputs.branch-name }}"
        if [[ " app beta alpha dev " == *" $BRANCH_NAME "* ]]; then
          echo "Deploying master template for branch: $BRANCH_NAME"
          echo "deploy-master=true" >> $GITHUB_OUTPUT
        else
          echo "Deploying application template only for branch: $BRANCH_NAME"
          echo "deploy-master=false" >> $GITHUB_OUTPUT
        fi

    - name: Calculate Source Checksum
      if: matrix.deploy
      id: checksum
      run: |
        # Calculate SHA256 checksum of all files in src/ directory
        SRC_CHECKSUM=$(find src -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
        echo "üìã Source checksum: $SRC_CHECKSUM"
        echo "src-checksum=$SRC_CHECKSUM" >> $GITHUB_OUTPUT

    - name: Install SAM CLI
      if: matrix.deploy
      run: |
        pip install aws-sam-cli

    - name: Configure AWS credentials
      if: matrix.deploy
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ matrix.region }}

    - name: Get AWS Account ID
      if: matrix.deploy
      id: account-id
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "AWS Account ID: $ACCOUNT_ID"
        echo "account-id=$ACCOUNT_ID" >> $GITHUB_OUTPUT

    - name: Get Bootstrap Stack Outputs
      if: matrix.deploy
      id: bootstrap-outputs
      run: |
        # Get TemplatesBucketName and WebECRRepositoryUri from bootstrap stack
        BOOTSTRAP_STACK_NAME="bootstrap"
        TEMPLATES_BUCKET_NAME=$(aws cloudformation describe-stacks --stack-name $BOOTSTRAP_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`TemplatesBucketName`].OutputValue' --output text)
        WEB_ECR_URI=$(aws cloudformation describe-stacks --stack-name $BOOTSTRAP_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`WebECRRepositoryUri`].OutputValue' --output text)
        echo "Templates bucket name: $TEMPLATES_BUCKET_NAME"
        echo "Web ECR URI: $WEB_ECR_URI"
        echo "templates-bucket-name=$TEMPLATES_BUCKET_NAME" >> $GITHUB_OUTPUT
        echo "web-ecr-uri=$WEB_ECR_URI" >> $GITHUB_OUTPUT

    - name: Generate Stack Names and Domain
      if: matrix.deploy
      id: stack-names
      run: |
        BRANCH_NAME="${{ needs.get-branch-name.outputs.branch-name }}"
        DOMAIN_NAME="${{ secrets.DOMAIN_NAME }}"

        # Create domain name for this deployment: branch.domain
        FULL_DOMAIN_NAME="${BRANCH_NAME}.${DOMAIN_NAME}"

        # Create stack name for web endpoint: replace periods with hyphens
        WEB_STACK_NAME=$(echo $FULL_DOMAIN_NAME | tr '.' '-')

        # If branch starts with a number, prepend 'x' to stack name
        if [[ $BRANCH_NAME =~ ^[0-9] ]]; then
          WEB_STACK_NAME="x${WEB_STACK_NAME}"
        fi

        echo "Branch name: $BRANCH_NAME"
        echo "Domain name: $DOMAIN_NAME"
        echo "Full domain name: $FULL_DOMAIN_NAME"
        echo "Web stack name: $WEB_STACK_NAME"

        echo "full-domain-name=$FULL_DOMAIN_NAME" >> $GITHUB_OUTPUT
        echo "web-stack-name=$WEB_STACK_NAME" >> $GITHUB_OUTPUT

    - name: Lookup Hosted Zone ID
      if: matrix.deploy
      id: hosted-zone
      run: |
        DOMAIN_NAME="${{ secrets.DOMAIN_NAME }}"

        echo "Looking up hosted zone ID for domain: $DOMAIN_NAME"

        # Use list-hosted-zones-by-name to find the hosted zone
        # This returns zones in DNS order, so the first match should be the most specific
        HOSTED_ZONE_ID=$(aws route53 list-hosted-zones-by-name \
          --dns-name "$DOMAIN_NAME" \
          --query "HostedZones[?contains(Name, '$DOMAIN_NAME.')].Id" \
          --output text | head -n 1 | cut -d '/' -f 3)

        if [ -z "$HOSTED_ZONE_ID" ]; then
          echo "‚ùå Could not find hosted zone for domain: $DOMAIN_NAME"
          exit 1
        fi

        echo "‚úÖ Found hosted zone ID: $HOSTED_ZONE_ID"
        echo "hosted-zone-id=$HOSTED_ZONE_ID" >> $GITHUB_OUTPUT

    - name: Check Templates Bucket Versioning
      if: matrix.deploy
      run: |
        BUCKET_NAME="${{ steps.bootstrap-outputs.outputs.templates-bucket-name }}"

        echo "üîç Checking versioning status for bucket: $BUCKET_NAME"

        # Check if bucket versioning is enabled
        VERSIONING_STATUS=$(aws s3api get-bucket-versioning --bucket $BUCKET_NAME --region ${{ matrix.region }} --query 'Status' --output text 2>/dev/null || echo "NotFound")

        if [ "$VERSIONING_STATUS" = "Enabled" ]; then
          echo "‚úÖ Bucket versioning is enabled for $BUCKET_NAME"
        elif [ "$VERSIONING_STATUS" = "NotFound" ]; then
          echo "‚ùå Bucket $BUCKET_NAME does not exist"
          exit 1
        else
          echo "‚ùå Bucket versioning is not enabled for $BUCKET_NAME (Status: $VERSIONING_STATUS)"
          echo "Required: Enabled"
          exit 1
        fi


    - name: Determine Deployment Configuration
      if: matrix.deploy
      id: deployment-config
      run: |
        # Determine if this is a multi-region deployment based on matrix configuration
        # If there are multiple regions in the matrix and both are deploying, it's multi-region
        IS_MULTI_REGION="false"

        # Check if this region is primary and if secondary region will also deploy
        if [[ "${{ matrix.is_primary }}" == "true" ]]; then
          # This is primary region - check if secondary will deploy
          if [[ "${{ contains(fromJson('["app","beta","dev"]'), needs.get-branch-name.outputs.branch-name) }}" == "true" ]]; then
            IS_MULTI_REGION="true"
          fi
        else
          # This is secondary region - it's always multi-region if it gets here
          IS_MULTI_REGION="true"
        fi

        # Convert boolean to CloudFormation AllowedValues
        if [[ "$IS_MULTI_REGION" == "true" ]]; then
          DEPLOYMENT_TYPE="multi"
        else
          DEPLOYMENT_TYPE="single"
        fi

        echo "Is multi-region deployment: $IS_MULTI_REGION"
        echo "Deployment type: $DEPLOYMENT_TYPE"
        echo "multi-region=$IS_MULTI_REGION" >> $GITHUB_OUTPUT
        echo "deployment-type=$DEPLOYMENT_TYPE" >> $GITHUB_OUTPUT

    - name: Build and package master template
      if: matrix.deploy && steps.deployment-type.outputs.deploy-master == 'true'
      run: |
        # Use TemplatesBucketName from bootstrap stack in us-east-1
        BUCKET_NAME="${{ steps.bootstrap-outputs.outputs.templates-bucket-name }}"
        BRANCH_NAME="${{ needs.get-branch-name.outputs.branch-name }}"
        echo "BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV

        echo "Building and packaging master template to S3 bucket: $BUCKET_NAME"
        sam build --template infrastructure/master.template --region ${{ matrix.region }}
        sam package --template-file .aws-sam/build/template.yaml --s3-bucket $BUCKET_NAME --s3-prefix $BRANCH_NAME --output-template-file packaged-master-template.yaml --region ${{ matrix.region }}

        # Upload the packaged template as master-template.yaml for compatibility
        aws s3 cp packaged-master-template.yaml s3://$BUCKET_NAME/$BRANCH_NAME/master-template.yaml --region ${{ matrix.region }}
        TEMPLATE_VERSION_ID=$(aws s3api head-object --bucket $BUCKET_NAME --key $BRANCH_NAME/master-template.yaml --query VersionId --output text)
        echo "TEMPLATE_VERSION_ID=$TEMPLATE_VERSION_ID" >> $GITHUB_ENV

    - name: Build and package application template
      if: matrix.deploy && steps.deployment-type.outputs.deploy-master == 'false'
      run: |
        # Use TemplatesBucketName from bootstrap stack in us-east-1
        BUCKET_NAME="${{ steps.bootstrap-outputs.outputs.templates-bucket-name }}"
        BRANCH_NAME="${{ needs.get-branch-name.outputs.branch-name }}"
        echo "BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV

        echo "Building and packaging application template to S3 bucket: $BUCKET_NAME"
        sam build --template infrastructure/application.template --region ${{ matrix.region }}
        sam package --template-file .aws-sam/build/template.yaml --s3-bucket $BUCKET_NAME --s3-prefix $BRANCH_NAME --output-template-file packaged-application-template.yaml --region ${{ matrix.region }}

        # Upload the packaged template as application-template.yaml for compatibility
        aws s3 cp packaged-application-template.yaml s3://$BUCKET_NAME/$BRANCH_NAME/application-template.yaml --region ${{ matrix.region }}
        TEMPLATE_VERSION_ID=$(aws s3api head-object --bucket $BUCKET_NAME --key $BRANCH_NAME/application-template.yaml --query VersionId --output text)
        echo "TEMPLATE_VERSION_ID=$TEMPLATE_VERSION_ID" >> $GITHUB_ENV

    - name: Check if Web Container Image Exists
      id: check-image
      if: matrix.deploy
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ matrix.region }}
      run: |
        SRC_CHECKSUM=${{ steps.checksum.outputs.src-checksum }}
        BRANCH_NAME=${{ needs.get-branch-name.outputs.branch-name }}
        SEMVER_TAG=${{ needs.build.outputs.customVersion }}

        # Get ECR repository URI from bootstrap stack
        ECR_REPO="${{ steps.bootstrap-outputs.outputs.web-ecr-uri }}"

        echo "üéØ ECR repository: $ECR_REPO"
        echo "üìã Checksum tag: $SRC_CHECKSUM"
        echo "üè∑Ô∏è SemVer tag: $SEMVER_TAG"

        # Check if image with checksum tag already exists
        if aws ecr describe-images --repository-name ecr-${ACCOUNT_ID}-${{ matrix.region }} --image-ids imageTag=$SRC_CHECKSUM --region ${{ matrix.region }} >/dev/null 2>&1; then
          echo "‚úÖ Image $ECR_REPO:$SRC_CHECKSUM already exists, reusing"
          echo "image-exists=true" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Image $ECR_REPO:$SRC_CHECKSUM does not exist, will build"
          echo "image-exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Build and Push Web Container Image
      if: matrix.deploy && steps.check-image.outputs.image-exists == 'false'
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ matrix.region }}
      run: |
        SRC_CHECKSUM=${{ steps.checksum.outputs.src-checksum }}
        BRANCH_NAME=${{ needs.get-branch-name.outputs.branch-name }}
        SEMVER_TAG=${{ needs.build.outputs.customVersion }}
        BRANCH_TAG=${BRANCH_NAME:-main}

        # Get ECR repository URI from bootstrap stack
        ECR_REPO="${{ steps.bootstrap-outputs.outputs.web-ecr-uri }}"

        echo "üéØ ECR repository: $ECR_REPO"
        echo "üìã Checksum tag: $SRC_CHECKSUM"
        echo "üè∑Ô∏è SemVer tag: $SEMVER_TAG"
        echo "üåø Branch tag: $BRANCH_TAG"

        # Build container image from root context
        docker build -t taskmanager-web:$SRC_CHECKSUM -f src/TaskManager.Web2/Dockerfile . --build-arg VERSION=${{ needs.build.outputs.customVersion }} --build-arg ASSEMBLY_VERSION=${{ needs.build.outputs.assemblySemVer }}

        # Login to ECR
        aws ecr get-login-password --region ${{ matrix.region }} | docker login --username AWS --password-stdin $ECR_REPO

        # Tag and push checksum-tagged image
        docker tag taskmanager-web:$SRC_CHECKSUM $ECR_REPO:$SRC_CHECKSUM
        docker push $ECR_REPO:$SRC_CHECKSUM
        echo "‚úÖ Pushed checksum image: $ECR_REPO:$SRC_CHECKSUM"

        # Also tag and push with SemVer for reference
        docker tag taskmanager-web:$SRC_CHECKSUM $ECR_REPO:$SEMVER_TAG
        docker push $ECR_REPO:$SEMVER_TAG
        echo "‚úÖ Pushed SemVer image: $ECR_REPO:$SEMVER_TAG"

        # Tag and push branch-specific image (for easy reference)
        docker tag taskmanager-web:$SRC_CHECKSUM $ECR_REPO:$BRANCH_TAG
        docker push $ECR_REPO:$BRANCH_TAG
        echo "‚úÖ Pushed branch image: $ECR_REPO:$BRANCH_TAG"

        # Also tag as latest for main branch
        if [ "$BRANCH_NAME" = "main" ]; then
          docker tag taskmanager-web:$SRC_CHECKSUM $ECR_REPO:latest
          docker push $ECR_REPO:latest
          echo "‚úÖ Pushed latest image: $ECR_REPO:latest"
        fi

    - name: Set Container Image Variable
      if: matrix.deploy
      run: |
        SRC_CHECKSUM=${{ steps.checksum.outputs.src-checksum }}
        ECR_REPO="${{ steps.bootstrap-outputs.outputs.web-ecr-uri }}"
        CONTAINER_IMAGE=$ECR_REPO:$SRC_CHECKSUM
        echo "CONTAINER_IMAGE=$CONTAINER_IMAGE" >> $GITHUB_ENV

    - name: Get primary region outputs for secondary
      id: get-primary-outputs
      if: matrix.is_primary == 'false' && matrix.deploy && steps.deployment-type.outputs.deploy-master == 'true'
      run: |
        echo "Getting outputs from primary region stack..."
        BRANCH_NAME="${{ needs.get-branch-name.outputs.branch-name }}"
        DOMAIN_NAME="${{ secrets.DOMAIN_NAME }}"

        # Create domain name for this deployment: branch.domain
        FULL_DOMAIN_NAME="${BRANCH_NAME}.${DOMAIN_NAME}"

        # Create stack name for primary stack: replace periods with hyphens
        PRIMARY_STACK_NAME=$(echo $FULL_DOMAIN_NAME | tr '.' '-')

        # If branch starts with a number, prepend 'x' to stack name
        if [[ $BRANCH_NAME =~ ^[0-9] ]]; then
          PRIMARY_STACK_NAME="x${PRIMARY_STACK_NAME}"
        fi

        echo "Primary stack name: $PRIMARY_STACK_NAME"
        KMS_KEY_ARN=$(aws cloudformation describe-stacks --stack-name $PRIMARY_STACK_NAME --region $AWS_REGION_PRIMARY --query 'Stacks[0].Outputs[?OutputKey==`AuroraKmsKeyArn`].OutputValue' --output text)
        GLOBAL_CLUSTER_ID=$(aws cloudformation describe-stacks --stack-name $PRIMARY_STACK_NAME --region $AWS_REGION_PRIMARY --query 'Stacks[0].Outputs[?OutputKey==`AuroraGlobalClusterId`].OutputValue' --output text)
        PRIMARY_LB_DNS=$(aws cloudformation describe-stacks --stack-name $PRIMARY_STACK_NAME --region $AWS_REGION_PRIMARY --query 'Stacks[0].Outputs[?OutputKey==`WebLoadBalancerDNS`].OutputValue' --output text)
        PRIMARY_LB_HZ=$(aws cloudformation describe-stacks --stack-name $PRIMARY_STACK_NAME --region $AWS_REGION_PRIMARY --query 'Stacks[0].Outputs[?OutputKey==`WebLoadBalancerHostedZoneId`].OutputValue' --output text)
        echo "kms-key-arn=$KMS_KEY_ARN" >> $GITHUB_OUTPUT
        echo "global-cluster-id=$GLOBAL_CLUSTER_ID" >> $GITHUB_OUTPUT
        echo "primary-lb-dns=$PRIMARY_LB_DNS" >> $GITHUB_OUTPUT
        echo "primary-lb-hz=$PRIMARY_LB_HZ" >> $GITHUB_OUTPUT

    - name: Get dev branch backend outputs for application-only deployment
      id: get-dev-backend-outputs
      if: matrix.deploy && steps.deployment-type.outputs.deploy-master == 'false'
      run: |
        echo "Getting backend outputs from dev branch stack..."
        BRANCH_NAME="dev"
        DOMAIN_NAME="${{ secrets.DOMAIN_NAME }}"

        # Create domain name for dev branch: dev.domain
        FULL_DOMAIN_NAME="${BRANCH_NAME}.${DOMAIN_NAME}"

        # Create stack name for dev backend stack: replace periods with hyphens
        DEV_STACK_NAME=$(echo $FULL_DOMAIN_NAME | tr '.' '-')

        echo "Dev backend stack name: $DEV_STACK_NAME"

        SHARED_LAMBDA_ROLE_ARN=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`SharedLambdaRoleArn`].OutputValue' --output text)
        DATABASE_HOST=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`DatabaseHost`].OutputValue' --output text)
        DATABASE_USERNAME=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`DatabaseUsername`].OutputValue' --output text)
        DATABASE_ENGINE=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`DatabaseEngine`].OutputValue' --output text)
        DATABASE_PORT=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`DatabasePort`].OutputValue' --output text)
        DATABASE_NAME=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`DatabaseName`].OutputValue' --output text)
        DATABASE_CLUSTER_ARN=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`DatabaseClusterArn`].OutputValue' --output text)
        DATABASE_PASSWORD_SECRET_ARN=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`DatabasePasswordSecretArn`].OutputValue' --output text)
        VPC_ID=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`VpcId`].OutputValue' --output text)
        PRIVATE_SUBNET_1_ID=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnet1Id`].OutputValue' --output text)
        PRIVATE_SUBNET_2_ID=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnet2Id`].OutputValue' --output text)
        PUBLIC_SUBNET_1_ID=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet1Id`].OutputValue' --output text)
        PUBLIC_SUBNET_2_ID=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet2Id`].OutputValue' --output text)
        LAMBDA_SECURITY_GROUP_ID=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`LambdaSecurityGroupId`].OutputValue' --output text)
        ALB_SECURITY_GROUP_ID=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`ALBSecurityGroupId`].OutputValue' --output text)
        ECS_TASK_SECURITY_GROUP_ID=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`ECSTaskSecurityGroupId`].OutputValue' --output text)
        ECS_CLUSTER_NAME=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`ECSClusterName`].OutputValue' --output text)
        GOOGLE_OAUTH_SECRET_ARN=$(aws cloudformation describe-stacks --stack-name $DEV_STACK_NAME --region ${{ matrix.region }} --query 'Stacks[0].Outputs[?OutputKey==`GoogleOAuthSecretArn`].OutputValue' --output text)

        echo "shared-lambda-role-arn=$SHARED_LAMBDA_ROLE_ARN" >> $GITHUB_OUTPUT
        echo "database-host=$DATABASE_HOST" >> $GITHUB_OUTPUT
        echo "database-username=$DATABASE_USERNAME" >> $GITHUB_OUTPUT
        echo "database-engine=$DATABASE_ENGINE" >> $GITHUB_OUTPUT
        echo "database-port=$DATABASE_PORT" >> $GITHUB_OUTPUT
        echo "database-name=$DATABASE_NAME" >> $GITHUB_OUTPUT
        echo "database-cluster-arn=$DATABASE_CLUSTER_ARN" >> $GITHUB_OUTPUT
        echo "database-password-secret-arn=$DATABASE_PASSWORD_SECRET_ARN" >> $GITHUB_OUTPUT
        echo "vpc-id=$VPC_ID" >> $GITHUB_OUTPUT
        echo "private-subnet-1-id=$PRIVATE_SUBNET_1_ID" >> $GITHUB_OUTPUT
        echo "private-subnet-2-id=$PRIVATE_SUBNET_2_ID" >> $GITHUB_OUTPUT
        echo "public-subnet-1-id=$PUBLIC_SUBNET_1_ID" >> $GITHUB_OUTPUT
        echo "public-subnet-2-id=$PUBLIC_SUBNET_2_ID" >> $GITHUB_OUTPUT
        echo "lambda-security-group-id=$LAMBDA_SECURITY_GROUP_ID" >> $GITHUB_OUTPUT
        echo "alb-security-group-id=$ALB_SECURITY_GROUP_ID" >> $GITHUB_OUTPUT
        echo "ecs-task-security-group-id=$ECS_TASK_SECURITY_GROUP_ID" >> $GITHUB_OUTPUT
        echo "ecs-cluster-name=$ECS_CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "google-oauth-secret-arn=$GOOGLE_OAUTH_SECRET_ARN" >> $GITHUB_OUTPUT


    - name: Set parameter overrides for master template
      id: set-master-params
      if: matrix.deploy && steps.deployment-type.outputs.deploy-master == 'true'
      run: |
        BRANCH_NAME="${{ needs.get-branch-name.outputs.branch-name }}"
        if [ "$BRANCH_NAME" = "app" ]; then
          MIN_CAP=0.5
          MAX_CAP=4
        else
          MIN_CAP=0
          MAX_CAP=1
        fi
        if [[ " app beta alpha dev " == *" $BRANCH_NAME "* ]]; then
          ENABLE_GLOBAL=true
        else
          ENABLE_GLOBAL=false
        fi
        BASE_PARAMS="BranchName=${{ needs.get-branch-name.outputs.branch-name }},DatabasePassword=${{ secrets.DATABASE_PASSWORD }},EngineVersion=${{ env.ENGINE_VERSION }},IsPrimaryRegion=${{ matrix.is_primary }},MinCapacity=$MIN_CAP,MaxCapacity=$MAX_CAP,EnableGlobalCluster=$ENABLE_GLOBAL,GoogleOAuthClientId=${{ secrets.GOOGLE_CLIENT_ID }},GoogleOAuthClientSecret=${{ secrets.GOOGLE_CLIENT_SECRET }},MicrosoftOAuthClientId=${{ secrets.MICROSOFT_CLIENT_ID }},MicrosoftOAuthClientSecret=${{ secrets.MICROSOFT_SECRET }},WebContainerImage=${{ env.CONTAINER_IMAGE }},DeploymentToken=${{ github.sha }},DomainName=${{ steps.stack-names.outputs.full-domain-name }},HostedZoneId=${{ steps.hosted-zone.outputs.hosted-zone-id }},DeploymentType=${{ steps.deployment-config.outputs.deployment-type }}"
        if [ "${{ matrix.is_primary }}" = "false" ]; then
          BASE_PARAMS="$BASE_PARAMS,AuroraGlobalClusterId=${{ steps.get-primary-outputs.outputs.global-cluster-id }},KmsKeyArn=${{ steps.get-primary-outputs.outputs.kms-key-arn }},PrimaryRegion=${{ env.AWS_REGION_PRIMARY }},PrimaryWebLoadBalancerDNS=${{ steps.get-primary-outputs.outputs.primary-lb-dns }},PrimaryWebLoadBalancerHostedZoneId=${{ steps.get-primary-outputs.outputs.primary-lb-hz }}"
        fi
        PARAMS="$BASE_PARAMS"
        echo "params=$PARAMS" >> $GITHUB_OUTPUT

    - name: Set parameter overrides for application template
      id: set-application-params
      if: matrix.deploy && steps.deployment-type.outputs.deploy-master == 'false'
      run: |
        # Application template parameters using dev branch backend outputs
        APP_PARAMS="TemplateBucket=${{ steps.bootstrap-outputs.outputs.templates-bucket-name }},GitHubActionsUserArn=${{ secrets.USER_ARN }},BranchName=${{ needs.get-branch-name.outputs.branch-name }},GoogleOAuthClientId=${{ secrets.GOOGLE_CLIENT_ID }},GoogleOAuthClientSecret=${{ secrets.GOOGLE_CLIENT_SECRET }},MicrosoftOAuthClientId=${{ secrets.MICROSOFT_CLIENT_ID }},MicrosoftOAuthClientSecret=${{ secrets.MICROSOFT_SECRET }},WebContainerImage=${{ env.CONTAINER_IMAGE }},DeploymentToken=${{ github.sha }},DomainName=${{ steps.stack-names.outputs.full-domain-name }},HostedZoneId=${{ steps.hosted-zone.outputs.hosted-zone-id }},DeploymentType=${{ steps.deployment-config.outputs.deployment-type }},IsPrimaryRegion=${{ matrix.is_primary }},SharedLambdaRoleArn=${{ steps.get-dev-backend-outputs.outputs.shared-lambda-role-arn }},DatabaseHost=${{ steps.get-dev-backend-outputs.outputs.database-host }},DatabaseUsername=${{ steps.get-dev-backend-outputs.outputs.database-username }},DatabaseEngine=${{ steps.get-dev-backend-outputs.outputs.database-engine }},DatabasePort=${{ steps.get-dev-backend-outputs.outputs.database-port }},DatabaseName=${{ steps.get-dev-backend-outputs.outputs.database-name }},DatabaseClusterArn=${{ steps.get-dev-backend-outputs.outputs.database-cluster-arn }},DatabasePasswordSecretArn=${{ steps.get-dev-backend-outputs.outputs.database-password-secret-arn }},VPCId=${{ steps.get-dev-backend-outputs.outputs.vpc-id }},PrivateSubnet1Id=${{ steps.get-dev-backend-outputs.outputs.private-subnet-1-id }},PrivateSubnet2Id=${{ steps.get-dev-backend-outputs.outputs.private-subnet-2-id }},PublicSubnet1Id=${{ steps.get-dev-backend-outputs.outputs.public-subnet-1-id }},PublicSubnet2Id=${{ steps.get-dev-backend-outputs.outputs.public-subnet-2-id }},LambdaSecurityGroupId=${{ steps.get-dev-backend-outputs.outputs.lambda-security-group-id }},ALBSecurityGroupId=${{ steps.get-dev-backend-outputs.outputs.alb-security-group-id }},ECSTaskSecurityGroupId=${{ steps.get-dev-backend-outputs.outputs.ecs-task-security-group-id }},ECSClusterName=${{ steps.get-dev-backend-outputs.outputs.ecs-cluster-name }},GoogleOAuthSecretArn=${{ steps.get-dev-backend-outputs.outputs.google-oauth-secret-arn }}"
        echo "params=$APP_PARAMS" >> $GITHUB_OUTPUT

    - name: Deploy master template
      id: deploy-master
      if: matrix.deploy && steps.deployment-type.outputs.deploy-master == 'true'
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: ${{ steps.stack-names.outputs.web-stack-name }}
        template: https://s3.${{ matrix.region }}.amazonaws.com/${{ steps.bootstrap-outputs.outputs.templates-bucket-name }}/${{ needs.get-branch-name.outputs.branch-name }}/master-template.yaml?versionId=${{ env.TEMPLATE_VERSION_ID }}
        parameter-overrides: ${{ steps.set-master-params.outputs.params }}
        capabilities: "CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND"
        no-fail-on-empty-changeset: "1"
        timeout-in-minutes: 30

    - name: Deploy application template
      id: deploy-application
      if: matrix.deploy && steps.deployment-type.outputs.deploy-master == 'false'
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: ${{ steps.stack-names.outputs.web-stack-name }}
        template: https://s3.${{ matrix.region }}.amazonaws.com/${{ steps.bootstrap-outputs.outputs.templates-bucket-name }}/${{ needs.get-branch-name.outputs.branch-name }}/application-template.yaml?versionId=${{ env.TEMPLATE_VERSION_ID }}
        parameter-overrides: ${{ steps.set-application-params.outputs.params }}
        capabilities: "CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND"
        no-fail-on-empty-changeset: "1"
        timeout-in-minutes: 30