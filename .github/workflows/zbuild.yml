# TaskManager CI/CD Pipeline - Shared Infrastructure + Branch Applications

name: Deploy Everything

on:
  push:
  pull_request:

env:
  AWS_REGION_SECONDARY: us-west-1
  AWS_REGION_PRIMARY: us-east-2
  ENGINE_VERSION: 8.0.mysql_aurora.3.10.0

jobs:
  get-branch-name:
    name: Get Branch Name
    runs-on: ubuntu-latest
    outputs:
      branch-name: ${{ steps.get-branch.outputs.branch-name }}
    steps:
    - name: Get branch name
      id: get-branch
      run: |
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT

  deploy-infrastructure:
    name: Deploy Regional Infrastructure
    needs: [get-branch-name]
    runs-on: ubuntu-latest
    concurrency:
      group: deploy-infrastructure-${{ matrix.region }}
      cancel-in-progress: false
    strategy:
      matrix:
        region: [us-east-2, us-west-1]  # Primary region first
        include:
          - region: us-east-2
            is_primary: "true"
          - region: us-west-1
            is_primary: "false"
    outputs:
      bucket-name: ${{ steps.deploy.outputs.TemplatesBucket }}
      web-ecr-repository-uri: ${{ steps.deploy.outputs.WebECRRepositoryUri }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ matrix.region }}

    - name: Cleanup failed infrastructure stack (if exists)
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-infrastructure \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")

        if [ "$STACK_STATUS" = "ROLLBACK_FAILED" ] || [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
          echo "üóëÔ∏è Deleting failed infrastructure stack: taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-infrastructure"
          aws cloudformation delete-stack \
            --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-infrastructure \
            --region ${{ matrix.region }}

          aws cloudformation wait stack-delete-complete \
            --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-infrastructure \
            --region ${{ matrix.region }}

          echo "‚úÖ Failed infrastructure stack cleaned up"
        fi

    - name: Deploy Regional Infrastructure
      id: deploy
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-infrastructure
        template: infrastructure/regional-setup.yaml
        parameter-overrides: BranchName=${{ needs.get-branch-name.outputs.branch-name }}
        no-fail-on-empty-changeset: "1"
        timeout-in-minutes: 5

  build-layers:
    name: Build MySQL Lambda Layer
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    concurrency:
      group: build-layers
      cancel-in-progress: false

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

  build:
    name: Build and Test Applications
    needs: build-layers
    runs-on: ubuntu-latest
    outputs:
      semVer: ${{ steps.gitversion.outputs.semVer }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x

    - name: Setup GitVersion
      uses: gittools/actions/gitversion/setup@v0
      with:
        versionSpec: '5.x'

    - name: Unshallow repository if needed
      run: |
        if [ "$(git rev-parse --is-shallow-repository)" = "true" ]; then
          echo "Repository is shallow, unshallowing..."
          git fetch --unshallow
        else
          echo "Repository is not shallow"
        fi

    - name: Determine Version
      id: gitversion
      uses: gittools/actions/gitversion/execute@v0
      with:
        useConfigFile: true

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore

    - name: Build
      run: |
        echo "Building with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet build --no-restore --configuration Release /p:Version=${{ steps.gitversion.outputs.semVer }} /p:AssemblyVersion=${{ steps.gitversion.outputs.assemblySemVer }} /p:FileVersion=${{ steps.gitversion.outputs.assemblySemVer }}

    - name: Test
      run: dotnet test --no-build --verbosity normal --configuration Release

    - name: Publish API for Lambda
      run: |
        echo "Publishing API with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet publish src/TaskManager.Api/TaskManager.Api.csproj --configuration Release --output ./publish/api --runtime linux-x64 --self-contained false /p:Version=${{ steps.gitversion.outputs.semVer }}

    - name: Publish Web for Container
      run: |
        echo "Publishing Web with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet publish src/TaskManager.Web2/TaskManager.Web2.csproj --configuration Release --output ./publish/web --runtime linux-x64 --self-contained false /p:Version=${{ steps.gitversion.outputs.semVer }}

    - name: Create API Lambda deployment package
      run: |
        cd ./publish/api
        zip -r ../../api-lambda-deployment.zip .

    - name: Upload API Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: api-lambda-package
        path: api-lambda-deployment.zip

    # Global layers are now created directly by build-layers with retention
    # No need to download and re-upload them

    - name: Create MySQL Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install PyMySQL (pure Python MySQL driver)
        pip install PyMySQL -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r mysql-layer.zip python/

        echo "MySQL layer created successfully"

    - name: Upload MySQL Layer
      uses: actions/upload-artifact@v4
      with:
        name: mysql-layer-package
        path: mysql-layer.zip



  deploy-global:
    name: Deploy Global Infrastructure
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, get-branch-name]
    concurrency:
      group: deploy-global
      cancel-in-progress: false
    outputs:
      shared-lambda-role-arn: ${{ steps.deploy-global.outputs.SharedLambdaRoleArn }}
      bastion-role-arn: ${{ steps.deploy-global.outputs.BastionRoleArn }}
      bastion-instance-profile-arn: ${{ steps.deploy-global.outputs.BastionInstanceProfileArn }}
      aurora-global-cluster-id: ${{ steps.deploy-global.outputs.AuroraGlobalClusterId }}
      aurora-kms-key-arn: ${{ steps.deploy-global.outputs.AuroraKmsKeyArn }}
      vpc-flow-logs-role-arn: ${{ steps.deploy-global.outputs.VPCFlowLogsRoleArn }}
      github-actions-user-arn: ${{ steps.get-github-user.outputs.github-actions-user-arn }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION_PRIMARY }}

    - name: Get GitHub Actions User ARN from IAM Setup Stack
      id: get-github-user
      run: |
        echo "üîç Retrieving GitHub Actions User ARN from IAM setup stack in us-east-1..."

        # Get the user ARN from the IAM setup stack export
        GITHUB_USER_ARN=$(aws cloudformation list-exports \
          --region us-east-1 \
          --query "Exports[?Name=='TaskManager-GitHubActionsUserArn'].Value" \
          --output text)

        if [ -z "$GITHUB_USER_ARN" ] || [ "$GITHUB_USER_ARN" = "None" ]; then
          echo "‚ùå ERROR: Could not retrieve GitHub Actions User ARN from IAM setup stack"
          echo "Please ensure the github-actions-iam-setup stack is deployed in us-east-1"
          exit 1
        fi

        echo "‚úÖ Retrieved GitHub Actions User ARN: $GITHUB_USER_ARN"
        echo "github-actions-user-arn=$GITHUB_USER_ARN" >> $GITHUB_OUTPUT

    - name: Deploy Global Infrastructure
      id: deploy-global
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-global-infrastructure-${{ needs.get-branch-name.outputs.branch-name }}
        template: infrastructure/global-template.yaml
        parameter-overrides: DatabasePassword=${{ secrets.DATABASE_PASSWORD }},EngineVersion=${{ env.ENGINE_VERSION }},GitHubActionsUserArn=${{ steps.get-github-user.outputs.github-actions-user-arn }},BranchName=${{ needs.get-branch-name.outputs.branch-name }}
        capabilities: "CAPABILITY_NAMED_IAM"
        no-fail-on-empty-changeset: "1"
        timeout-in-minutes: 20
  deploy-regional:
    name: Deploy Regional Stack
    runs-on: ubuntu-latest
    needs: [build, deploy-global, deploy-infrastructure, get-branch-name]
    concurrency:
      group: deploy-regional-${{ matrix.region }}
      cancel-in-progress: false
    strategy:
      matrix:
        region: [us-east-2, us-west-1]  # Primary region first
        include:
          - region: us-east-2
            is_primary: "true"
          - region: us-west-1
            is_primary: "false"
    outputs:
      vpc-id: ${{ steps.deploy-regional-vpc-db.outputs.VPCId }}
      private-subnet-1: ${{ steps.deploy-regional-vpc-db.outputs.PrivateSubnet1Id }}
      private-subnet-2: ${{ steps.deploy-regional-vpc-db.outputs.PrivateSubnet2Id }}
      public-subnet-1: ${{ steps.deploy-regional-vpc-db.outputs.PublicSubnet1Id }}
      public-subnet-2: ${{ steps.deploy-regional-vpc-db.outputs.PublicSubnet2Id }}
      lambda-sg: ${{ steps.deploy-regional-vpc-db.outputs.LambdaSecurityGroupId }}
      rds-sg: ${{ steps.deploy-regional-vpc-db.outputs.RDSSecurityGroupId }}
      bastion-sg: ${{ steps.deploy-regional-vpc-db.outputs.BastionSecurityGroupId }}
      alb-sg: ${{ steps.deploy-regional-vpc-db.outputs.ALBSecurityGroupId }}
      ecs-sg: ${{ steps.deploy-regional-vpc-db.outputs.ECSTaskSecurityGroupId }}
      db-endpoint: ${{ steps.deploy-regional-vpc-db.outputs.DatabaseEndpoint }}
      db-reader-endpoint: ${{ steps.deploy-regional-vpc-db.outputs.DatabaseReaderEndpoint }}
      db-secret-arn: ${{ steps.deploy-regional-vpc-db.outputs.DatabaseSecretArn }}
      web-ecr-repository-uri: ${{ needs.deploy-infrastructure.outputs.web-ecr-repository-uri }}
      bastion-host-ip: ${{ steps.deploy-regional.outputs.BastionHostIP }}
      database-tunnel-command: ${{ steps.deploy-regional.outputs.DatabaseTunnelCommand }}
      ecs-cluster-name: ${{ steps.deploy-regional.outputs.ECSClusterName }}
      api-endpoint: ${{ steps.get-endpoints.outputs.api-endpoint }}
      web-endpoint: ${{ steps.get-endpoints.outputs.web-endpoint }}
      web-load-balancer-dns: ${{ steps.deploy-wrapper.outputs.WebLoadBalancerDNS }}
      web-load-balancer-hosted-zone-id: ${{ steps.deploy-wrapper.outputs.WebLoadBalancerHostedZoneId }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ matrix.region }}

    - name: Echo GitHub Actions User ARN
      run: |
        echo "üîë GitHub Actions User ARN: ${{ needs.deploy-global.outputs.github-actions-user-arn }}"

    - name: Upload regional templates to S3
      run: |
        echo "Uploading regional templates to S3..."
        aws s3 cp infrastructure/regional-vpc-db.yaml s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}
        aws s3 cp infrastructure/regional-kms-replica.yaml s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}

    - name: Deploy Regional KMS Replica (Secondary Region Only)
      if: matrix.region == 'us-west-1'
      id: deploy-kms-replica
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-kms-replica
        template: infrastructure/regional-kms-replica.yaml
        parameter-overrides: PrimaryKeyArn=${{ needs.deploy-global.outputs.aurora-kms-key-arn }},GitHubActionsUserArn=${{ needs.deploy-global.outputs.github-actions-user-arn }},BranchName=${{ needs.get-branch-name.outputs.branch-name }}
        no-fail-on-empty-changeset: "1"
        timeout-in-minutes: 10

    - name: Cleanup failed regional-vpc-db stack (if exists)
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-vpc-db-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")

        if [ "$STACK_STATUS" = "ROLLBACK_FAILED" ] || [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
          echo "üóëÔ∏è Deleting failed regional-vpc-db stack: taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-vpc-db-${{ matrix.region }}"
          aws cloudformation delete-stack \
            --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-vpc-db-${{ matrix.region }} \
            --region ${{ matrix.region }}

          aws cloudformation wait stack-delete-complete \
            --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-vpc-db-${{ matrix.region }} \
            --region ${{ matrix.region }}

          echo "‚úÖ Failed regional-vpc-db stack cleaned up"
        fi

    - name: Deploy Regional Database
      id: deploy-regional-vpc-db
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-vpc-db
        template: infrastructure/regional-vpc-db.yaml
        parameter-overrides: "BranchName=${{ needs.get-branch-name.outputs.branch-name }},DatabasePassword=${{ secrets.DATABASE_PASSWORD }},EngineVersion=${{ env.ENGINE_VERSION }},AuroraGlobalClusterId=${{ needs.deploy-global.outputs.aurora-global-cluster-id }},AuroraKmsKeyArn=${{ matrix.region == 'us-west-1' && steps.deploy-kms-replica.outputs.AuroraKmsKeyReplicaArn || needs.deploy-global.outputs.aurora-kms-key-arn }},IsPrimaryRegion=${{ matrix.is_primary }},GitHubActionsUserArn=${{ needs.deploy-global.outputs.github-actions-user-arn }},VPCFlowLogsRoleArn=${{ needs.deploy-global.outputs.vpc-flow-logs-role-arn }},LogRetentionDays=7"
        capabilities: "CAPABILITY_NAMED_IAM"
        no-fail-on-empty-changeset: "1"
        timeout-in-minutes: 30

    - name: Upload templates and regional layers to S3
      run: |
        # Upload all templates
        echo "Uploading templates to S3..."
        aws s3 cp infrastructure/regional-infrastructure.yaml s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}
        aws s3 cp infrastructure/regional-vpc-db.yaml s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}
        aws s3 cp infrastructure/regional-kms-replica.yaml s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}
        aws s3 cp src/TaskManager.Api/api-template.yaml s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}
        aws s3 cp src/TaskManager.Web2/web-template.yaml s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}
        aws s3 cp infrastructure/wrapper-template.yaml s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}

        # Verify uploads
        echo "Verifying S3 uploads..."
        aws s3 ls s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}

    - name: Validate Parameter Values
      run: |
        echo "üîç Debug: Parameter values being passed to CloudFormation:"
        echo "DatabasePassword: [REDACTED]"
        echo "SharedLambdaRoleArn: ${{ needs.deploy-global.outputs.shared-lambda-role-arn }}"
        echo "BastionRoleArn: ${{ needs.deploy-global.outputs.bastion-role-arn }}"
        echo "DatabaseSecretArn: ${{ steps.deploy-regional-vpc-db.outputs.DatabaseSecretArn }}"
        echo "BastionInstanceProfileArn: ${{ needs.deploy-global.outputs.bastion-instance-profile-arn }}"
        echo "AuroraGlobalClusterId: ${{ needs.deploy-global.outputs.aurora-global-cluster-id }}"

        # Validate that job outputs are not empty
        if [ -z "${{ needs.deploy-global.outputs.shared-lambda-role-arn }}" ]; then
          echo "‚ùå ERROR: SharedLambdaRoleArn is empty"
          exit 1
        fi

        if [ -z "${{ needs.deploy-global.outputs.bastion-role-arn }}" ]; then
          echo "‚ùå ERROR: BastionRoleArn is empty"
          exit 1
        fi

        if [ -z "${{ steps.deploy-regional-vpc-db.outputs.DatabaseSecretArn }}" ]; then
          echo "‚ùå ERROR: DatabaseSecretArn is empty"
          exit 1
        fi

        if [ -z "${{ needs.deploy-global.outputs.bastion-instance-profile-arn }}" ]; then
          echo "‚ùå ERROR: BastionInstanceProfileArn is empty"
          exit 1
        fi

        if [ -z "${{ needs.deploy-global.outputs.aurora-global-cluster-id }}" ]; then
          echo "‚ùå ERROR: AuroraGlobalClusterId is empty"
          exit 1
        fi

        echo "‚úÖ All parameter values are present, proceeding with deployment..."

    - name: Cleanup failed regional stack (if exists)
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")

        if [ "$STACK_STATUS" = "ROLLBACK_FAILED" ] || [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
          echo "üóëÔ∏è Deleting failed regional stack: taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-${{ matrix.region }}"
          aws cloudformation delete-stack \
            --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-${{ matrix.region }} \
            --region ${{ matrix.region }}

          aws cloudformation wait stack-delete-complete \
            --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-${{ matrix.region }} \
            --region ${{ matrix.region }}

          echo "‚úÖ Failed regional stack cleaned up"
        fi

    - name: Deploy Regional Infrastructure
      id: deploy-regional
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-infrastructure
        template: infrastructure/regional-infrastructure.yaml
        parameter-overrides: "DatabasePassword=${{ secrets.DATABASE_PASSWORD }},SharedLambdaRoleArn=${{ needs.deploy-global.outputs.shared-lambda-role-arn }},BastionRoleArn=${{ needs.deploy-global.outputs.bastion-role-arn }},BastionInstanceProfileArn=${{ needs.deploy-global.outputs.bastion-instance-profile-arn }},AuroraGlobalClusterId=${{ needs.deploy-global.outputs.aurora-global-cluster-id }},AuroraKmsKeyArn=${{ needs.deploy-global.outputs.aurora-kms-key-arn }},EngineVersion=${{ env.ENGINE_VERSION }},VPCId=${{ steps.deploy-regional-vpc-db.outputs.VPCId }},PrivateSubnet1Id=${{ steps.deploy-regional-vpc-db.outputs.PrivateSubnet1Id }},PrivateSubnet2Id=${{ steps.deploy-regional-vpc-db.outputs.PrivateSubnet2Id }},PublicSubnet1Id=${{ steps.deploy-regional-vpc-db.outputs.PublicSubnet1Id }},PublicSubnet2Id=${{ steps.deploy-regional-vpc-db.outputs.PublicSubnet2Id }},LambdaSecurityGroupId=${{ steps.deploy-regional-vpc-db.outputs.LambdaSecurityGroupId }},RDSSecurityGroupId=${{ steps.deploy-regional-vpc-db.outputs.RDSSecurityGroupId }},BastionSecurityGroupId=${{ steps.deploy-regional-vpc-db.outputs.BastionSecurityGroupId }},ALBSecurityGroupId=${{ steps.deploy-regional-vpc-db.outputs.ALBSecurityGroupId }},ECSTaskSecurityGroupId=${{ steps.deploy-regional-vpc-db.outputs.ECSTaskSecurityGroupId }},DatabaseEndpoint=${{ steps.deploy-regional-vpc-db.outputs.DatabaseEndpoint }},DatabaseReaderEndpoint=${{ steps.deploy-regional-vpc-db.outputs.DatabaseReaderEndpoint }},GoogleOAuthClientId=${{ secrets.GOOGLE_OAUTH_CLIENT_ID }},GoogleOAuthClientSecret=${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET }}"
        capabilities: "CAPABILITY_NAMED_IAM"
        no-fail-on-empty-changeset: "1"
        timeout-in-minutes: 20
    - name: Build and Push Web Container Image
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION_SECONDARY }}
      run: |
        # Use GitVersion for unique image tagging
        BRANCH_NAME=${{ needs.get-branch-name.outputs.branch-name }}
        IMAGE_TAG=${{ needs.build.outputs.semVer }}
        BRANCH_TAG=${BRANCH_NAME:-main}

        # Get ECR repository URI from job outputs
        ECR_REPO="${{ needs.deploy-infrastructure.outputs.web-ecr-repository-uri }}"

        # Validate ECR repo URI
        if [ -z "$ECR_REPO" ]; then
          echo "‚ùå ERROR: ECR repository URI not found in job outputs"
          exit 1
        fi

        echo "‚úÖ Successfully retrieved ECR URI from job outputs: $ECR_REPO"
        echo "üéØ Final ECR repository: $ECR_REPO"
        echo "üè∑Ô∏è Version tag: $IMAGE_TAG"
        echo "üåø Branch tag: $BRANCH_TAG"

        # Build container image from root context
        docker build -t taskmanager-web:$IMAGE_TAG -f src/TaskManager.Web2/Dockerfile .

        # Login to ECR
        aws ecr get-login-password --region ${{ matrix.region }} | docker login --username AWS --password-stdin $ECR_REPO

        # Tag and push versioned image
        docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:$IMAGE_TAG
        docker push $ECR_REPO:$IMAGE_TAG
        echo "‚úÖ Pushed versioned image: $ECR_REPO:$IMAGE_TAG"

        # Tag and push branch-specific image (for easy reference)
        docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:$BRANCH_TAG
        docker push $ECR_REPO:$BRANCH_TAG
        echo "‚úÖ Pushed branch image: $ECR_REPO:$BRANCH_TAG"

        # Also tag as latest for main branch
        if [ "$BRANCH_NAME" = "main" ]; then
          docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:latest
          docker push $ECR_REPO:latest
          echo "‚úÖ Pushed latest image: $ECR_REPO:latest"
        fi

        CONTAINER_IMAGE=$ECR_REPO:$IMAGE_TAG
        echo "CONTAINER_IMAGE=$CONTAINER_IMAGE" >> $GITHUB_ENV

    - name: Get branch name for stack naming
      run: |
        BRANCH_NAME=${{ needs.get-branch-name.outputs.branch-name }}
        STACK_PREFIX="taskmanager-${BRANCH_NAME}"
        echo "Branch: $BRANCH_NAME"
        echo "Stack name: $STACK_PREFIX"
        echo "STACK_PREFIX=$STACK_PREFIX" >> $GITHUB_ENV
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

    - name: Setup SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        use-installer: true

    - name: Cleanup failed branch stack (if exists)
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_PREFIX }}-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")

        if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
          echo "üóëÔ∏è Deleting failed branch stack: ${{ env.STACK_PREFIX }}-${{ matrix.region }}"
          aws cloudformation delete-stack \
            --stack-name ${{ env.STACK_PREFIX }}-${{ matrix.region }} \
            --region ${{ matrix.region }}

          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.STACK_PREFIX }}-${{ matrix.region }} \
            --region ${{ matrix.region }}

          echo "‚úÖ Failed branch stack cleaned up"
        fi

    - name: Download Lambda packages
      uses: actions/download-artifact@v4
      with:
        name: api-lambda-package
        path: ./artifacts/

    - name: Download MySQL Layer
      uses: actions/download-artifact@v4
      with:
        name: mysql-layer-package
        path: ./artifacts/

    - name: Upload templates and packages to S3
      run: |
        # Debug: List downloaded artifacts
        echo "Downloaded artifacts:"
        ls -la ./artifacts/

        # Upload Lambda deployment packages
        aws s3 cp ./artifacts/api-lambda-deployment.zip s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/api-lambda-deployment.zip --region ${{ matrix.region }}

        # Upload MySQL layer
        aws s3 cp ./artifacts/mysql-layer.zip s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/mysql-layer.zip --region ${{ matrix.region }}

        # Verify uploads
        echo "S3 bucket contents:"
        aws s3 ls s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }} | grep -E "(api-lambda-deployment|mysql-layer)"

    - name: Deploy Wrapper Template (Nested Stacks)
      id: deploy-wrapper
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: ${{ env.STACK_PREFIX }}-wrapper
        template: infrastructure/wrapper-template.yaml
        parameter-overrides: Environment=${{ needs.get-branch-name.outputs.branch-name }},ApiCodeBucket=taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }},WebContainerImage=${{ env.CONTAINER_IMAGE }},DeploymentToken=${{ github.sha }},DomainName=appcloud.systems,HostedZoneId=Z06422172SASV44F5Y8VA,TemplatesBucket=taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ matrix.region }},SharedLambdaRoleArn=${{ needs.deploy-global.outputs.shared-lambda-role-arn }},VPCId=${{ steps.deploy-regional-vpc-db.outputs.VPCId }},LambdaSecurityGroupId=${{ steps.deploy-regional-vpc-db.outputs.LambdaSecurityGroupId }},PrivateSubnet1Id=${{ steps.deploy-regional-vpc-db.outputs.PrivateSubnet1Id }},PrivateSubnet2Id=${{ steps.deploy-regional-vpc-db.outputs.PrivateSubnet2Id }},ALBSecurityGroupId=${{ steps.deploy-regional-vpc-db.outputs.ALBSecurityGroupId }},ECSTaskSecurityGroupId=${{ steps.deploy-regional-vpc-db.outputs.ECSTaskSecurityGroupId }},PublicSubnet1Id=${{ steps.deploy-regional-vpc-db.outputs.PublicSubnet1Id }},PublicSubnet2Id=${{ steps.deploy-regional-vpc-db.outputs.PublicSubnet2Id }},ECSClusterName=${{ steps.deploy-regional.outputs.ECSClusterName }},GoogleOAuthSecretArn=${{ steps.deploy-regional.outputs.GoogleOAuthSecretArn }},LogRetentionDays=7
        capabilities: "CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 20

    # Database setup removed - now handled automatically by Entity Framework
    # EF will create the database and run migrations when the API first starts

    - name: Get deployment outputs
      id: get-endpoints
      run: |
        echo "Getting deployment outputs from stack outputs..."

        # Get API endpoint from wrapper stack outputs
        API_URL="${{ steps.deploy-wrapper.outputs.TaskManagerApiEndpoint }}"

        if [ -z "$API_URL" ]; then
          echo "‚ùå API endpoint not found in stack outputs"
          exit 1
        fi
        echo "‚úÖ API endpoint: $API_URL"

        # Get Web endpoint from wrapper stack outputs
        WEB_URL="${{ steps.deploy-wrapper.outputs.WebLoadBalancerDNS }}"

        if [ -z "$WEB_URL" ]; then
          echo "‚ö†Ô∏è Web endpoint not found in stack outputs"
          WEB_URL=""
        else
          echo "‚úÖ Web endpoint: $WEB_URL"
        fi

        BASTION_IP="${{ steps.deploy-regional.outputs.BastionHostIP }}"
        TUNNEL_CMD="${{ steps.deploy-regional.outputs.DatabaseTunnelCommand }}"

        # Extract API Gateway ID from URL
        API_GATEWAY_ID=$(echo $API_URL | sed 's|https://||' | sed 's|\.execute-api.*||')

        echo "üöÄ TaskManager (${{ needs.get-branch-name.outputs.branch-name }}) deployed successfully in ${{ matrix.region }}!"
        echo "üìã API Stack: ${{ env.STACK_PREFIX }}-${{ matrix.region }}-api ‚úÖ Endpoint: $API_URL"
        echo "üìã Web Stack: ${{ env.STACK_PREFIX }}-${{ matrix.region }}-web ‚úÖ Load Balancer: $WEB_URL"
        echo "üñ•Ô∏è Bastion host IP: $BASTION_IP"
        echo "üíæ Database: taskmanager_${{ needs.get-branch-name.outputs.branch-name }} ‚úÖ Auto-created by EF"
        echo "üîó SSH Tunnel: $TUNNEL_CMD"

        # Set outputs for other jobs
        echo "api-endpoint=$API_URL" >> $GITHUB_OUTPUT
        echo "web-endpoint=$WEB_URL" >> $GITHUB_OUTPUT
        echo "api-gateway-id=$API_GATEWAY_ID" >> $GITHUB_OUTPUT

    - name: Send SMS Notification
      run: |
        # Note: SMS notification disabled as SNS topic is not defined in global template
        echo "üì± SMS notification skipped - SNS topic not configured in global infrastructure"
        echo "üöÄ TaskManager deployment complete! Branch: ${{ needs.get-branch-name.outputs.branch-name }} Region: ${{ matrix.region }} API: $API_URL Web App: https://$BRANCH_NAME.appcloud.systems Database: taskmanager_${{ needs.get-branch-name.outputs.branch-name }} ‚úÖ Auto-created by EF Bastion IP: $BASTION_IP Both API and Web are fully deployed and running!"

    - name: Verify All Deployments
      run: |
        echo "üîç Final verification of all deployments in ${{ matrix.region }}..."

        # Check global infrastructure (only for us-east-1)
        if [ "${{ matrix.region }}" = "us-east-1" ]; then
          echo "Checking global infrastructure..."
          GLOBAL_STATUS=$(aws cloudformation describe-stacks \
            --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-global-infrastructure \
            --region us-east-1 \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "NOT_FOUND")

          if [ "$GLOBAL_STATUS" != "CREATE_COMPLETE" ] && [ "$GLOBAL_STATUS" != "UPDATE_COMPLETE" ]; then
            echo "‚ùå Global infrastructure deployment failed: $GLOBAL_STATUS"
            exit 1
          fi
          echo "‚úÖ Global infrastructure: $GLOBAL_STATUS"
        fi

        # Check regional database
        echo "Checking regional database..."
        REGIONAL_DB_STATUS=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-vpc-db-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "NOT_FOUND")

        if [ "$REGIONAL_DB_STATUS" != "CREATE_COMPLETE" ] && [ "$REGIONAL_DB_STATUS" != "UPDATE_COMPLETE" ]; then
          echo "‚ùå Regional database deployment failed: $REGIONAL_DB_STATUS"
          exit 1
        fi
        echo "‚úÖ Regional database: $REGIONAL_DB_STATUS"

        # Check regional infrastructure
        echo "Checking regional infrastructure..."
        REGIONAL_STATUS=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-regional-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "NOT_FOUND")

        if [ "$REGIONAL_STATUS" != "CREATE_COMPLETE" ] && [ "$REGIONAL_STATUS" != "UPDATE_COMPLETE" ]; then
          echo "‚ùå Regional infrastructure deployment failed: $REGIONAL_STATUS"
          exit 1
        fi
        echo "‚úÖ Regional infrastructure: $REGIONAL_STATUS"

        # Check application deployment
        BRANCH_NAME=${{ needs.get-branch-name.outputs.branch-name }}
        STACK_PREFIX="taskmanager-${BRANCH_NAME}"

        echo "Checking application deployment..."
        APP_STATUS=$(aws cloudformation describe-stacks \
          --stack-name ${STACK_PREFIX}-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "NOT_FOUND")

        if [ "$APP_STATUS" != "CREATE_COMPLETE" ] && [ "$APP_STATUS" != "UPDATE_COMPLETE" ]; then
          echo "‚ùå Application deployment failed: $APP_STATUS"
          exit 1
        fi
        echo "‚úÖ Application deployment: $APP_STATUS"

        echo "üéâ All deployments verified successfully in ${{ matrix.region }}!"




  deploy-global-dns:
    name: Deploy Global DNS Failover
    runs-on: ubuntu-latest
    needs: [deploy-regional, get-branch-name]
    if: needs.deploy-regional.result == 'success'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Upload Global DNS template to S3
      run: |
        echo "Uploading global DNS template to S3..."
        aws s3 cp infrastructure/global-dns-template.yaml s3://taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-templates-bucket-${{ env.AWS_REGION_PRIMARY }}/ --region ${{ env.AWS_REGION_PRIMARY }}

    - name: Get Load Balancer Details
      id: get-lb-details
      run: |
        BRANCH_NAME=${{ needs.get-branch-name.outputs.branch-name }}

        # Get primary load balancer details
        PRIMARY_DNS=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-${BRANCH_NAME}-wrapper \
          --region ${{ env.AWS_REGION_PRIMARY }} \
          --query 'Stacks[0].Outputs[?OutputKey==`WebLoadBalancerDNS`].OutputValue' \
          --output text)

        PRIMARY_HZ=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-${BRANCH_NAME}-wrapper \
          --region ${{ env.AWS_REGION_PRIMARY }} \
          --query 'Stacks[0].Outputs[?OutputKey==`WebLoadBalancerHostedZoneId`].OutputValue' \
          --output text)

        # Get secondary load balancer details
        SECONDARY_DNS=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-${BRANCH_NAME}-wrapper \
          --region ${{ env.AWS_REGION_SECONDARY }} \
          --query 'Stacks[0].Outputs[?OutputKey==`WebLoadBalancerDNS`].OutputValue' \
          --output text)

        SECONDARY_HZ=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-${BRANCH_NAME}-wrapper \
          --region ${{ env.AWS_REGION_SECONDARY }} \
          --query 'Stacks[0].Outputs[?OutputKey==`WebLoadBalancerHostedZoneId`].OutputValue' \
          --output text)

        echo "Primary DNS: $PRIMARY_DNS"
        echo "Primary HZ: $PRIMARY_HZ"
        echo "Secondary DNS: $SECONDARY_DNS"
        echo "Secondary HZ: $SECONDARY_HZ"

        echo "primary-web-load-balancer-dns=$PRIMARY_DNS" >> $GITHUB_OUTPUT
        echo "primary-web-load-balancer-hosted-zone-id=$PRIMARY_HZ" >> $GITHUB_OUTPUT
        echo "secondary-web-load-balancer-dns=$SECONDARY_DNS" >> $GITHUB_OUTPUT
        echo "secondary-web-load-balancer-hosted-zone-id=$SECONDARY_HZ" >> $GITHUB_OUTPUT

    - name: Deploy Global DNS Failover Stack
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-global-dns
        template: infrastructure/global-dns-template.yaml
        parameter-overrides: Environment=${{ needs.get-branch-name.outputs.branch-name }},DomainName=appcloud.systems,HostedZoneId=Z06422172SASV44F5Y8VA,PrimaryRegion=${{ env.AWS_REGION_PRIMARY }},SecondaryRegion=${{ env.AWS_REGION_SECONDARY }},PrimaryWebLoadBalancerDNS=${{ steps.get-lb-details.outputs.primary-web-load-balancer-dns }},PrimaryWebLoadBalancerHostedZoneId=${{ steps.get-lb-details.outputs.primary-web-load-balancer-hosted-zone-id }},SecondaryWebLoadBalancerDNS=${{ steps.get-lb-details.outputs.secondary-web-load-balancer-dns }},SecondaryWebLoadBalancerHostedZoneId=${{ steps.get-lb-details.outputs.secondary-web-load-balancer-hosted-zone-id }}
        no-fail-on-empty-changeset: "1"
        timeout-in-minutes: 10

    - name: Verify DNS Failover Setup
      run: |
        echo "üîç Verifying DNS failover configuration..."

        # Check health checks
        PRIMARY_HC=$(aws route53 get-health-check \
          --health-check-id $(aws cloudformation describe-stacks \
            --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-global-dns \
            --query 'Stacks[0].Outputs[?OutputKey==`PrimaryHealthCheckId`].OutputValue' \
            --output text) \
          --query 'HealthCheck.HealthCheckConfig.FullyQualifiedDomainName' \
          --output text 2>/dev/null || echo "NOT_FOUND")

        SECONDARY_HC=$(aws route53 get-health-check \
          --health-check-id $(aws cloudformation describe-stacks \
            --stack-name taskmanager-${{ needs.get-branch-name.outputs.branch-name }}-global-dns \
            --query 'Stacks[0].Outputs[?OutputKey==`SecondaryHealthCheckId`].OutputValue' \
            --output text) \
          --query 'HealthCheck.HealthCheckConfig.FullyQualifiedDomainName' \
          --output text 2>/dev/null || echo "NOT_FOUND")

        if [ "$PRIMARY_HC" != "NOT_FOUND" ] && [ "$SECONDARY_HC" != "NOT_FOUND" ]; then
          echo "‚úÖ DNS failover health checks configured:"
          echo "  Primary: $PRIMARY_HC"
          echo "  Secondary: $SECONDARY_HC"
        else
          echo "‚ùå DNS failover health checks not found"
          exit 1
        fi

        # Check DNS records
        RECORDS=$(aws route53 list-resource-record-sets \
          --hosted-zone-id Z06422172SASV44F5Y8VA \
          --query "ResourceRecordSets[?Name=='${{ needs.get-branch-name.outputs.branch-name }}.appcloud.systems.']" \
          --output text)

        if [ -n "$RECORDS" ]; then
          echo "‚úÖ DNS failover records configured for ${{ needs.get-branch-name.outputs.branch-name }}.appcloud.systems"
        else
          echo "‚ùå DNS failover records not found"
          exit 1
        fi

  update-google-oauth:
    name: Generate Google OAuth Update Instructions
    runs-on: ubuntu-latest
    needs: [deploy-global-dns]
    if: needs.deploy-global-dns.result == 'success'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Update Google OAuth Configuration
      run: |
        chmod +x update-google-oauth.sh
        ./update-google-oauth.sh "${{ needs.deploy-regional.outputs.api-endpoint }}" "${{ needs.deploy-regional.outputs.web-endpoint }}"
