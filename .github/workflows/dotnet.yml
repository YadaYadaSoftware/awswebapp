# TaskManager CI/CD Pipeline - Shared Infrastructure + Branch Applications

name: TaskManager CI/CD

on:
  push:
  pull_request:

env:
  AWS_REGION: us-east-1
  AWS_REGION_2: us-east-2
  ENGINE_VERSION: 8.0.mysql_aurora.3.10.0

jobs:
  yaml-lint:
    name: YAML Lint
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Install yamllint
      run: pip install yamllint

    - name: Lint YAML files
      run: |
        echo "Linting all .yml and .yaml files in the repository (excluding .github/workflows/dotnet.yml)..."
        find . -name "*.yml" -o -name "*.yaml" | grep -v ".github/workflows/dotnet.yml" | while read file; do
          echo "Linting: $file"
          yamllint -c .yamllint.yml "$file"
        done

        # Check if any linting errors occurred
        if find . -name "*.yml" -o -name "*.yaml" | grep -v ".github/workflows/dotnet.yml" | xargs yamllint -c .yamllint.yml | grep -q "error"; then
          echo "‚ùå YAML linting failed!"
          exit 1
        else
          echo "‚úÖ All YAML files passed linting!"
        fi

  deploy-bucket:
    name: Deploy Regional Bucket
    runs-on: ubuntu-latest
    concurrency:
      group: deploy-bucket
      cancel-in-progress: false
    strategy:
      matrix:
        region: [us-east-2, us-east-1]
    outputs:
      bucket-name: ${{ steps.deploy.outputs.TemplatesBucket }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ matrix.region }}

    - name: Cleanup failed bucket stack (if exists)
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-regional-bucket-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")

        if [ "$STACK_STATUS" = "ROLLBACK_FAILED" ] || [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
          echo "üóëÔ∏è Deleting failed bucket stack: taskmanager-regional-bucket-${{ matrix.region }}"
          aws cloudformation delete-stack \
            --stack-name taskmanager-regional-bucket-${{ matrix.region }} \
            --region ${{ matrix.region }}

          aws cloudformation wait stack-delete-complete \
            --stack-name taskmanager-regional-bucket-${{ matrix.region }} \
            --region ${{ matrix.region }}

          echo "‚úÖ Failed bucket stack cleaned up"
        fi

    - name: Deploy Regional Bucket
      id: deploy
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-regional-bucket-${{ matrix.region }}
        template: infrastructure/regional-bucket.yaml
        no-fail-on-empty-changeset: "1"

  build-layers:
    name: Build Global Infrastructure Layers
    runs-on: ubuntu-latest
    needs: deploy-bucket
    concurrency:
      group: build-layers
      cancel-in-progress: false

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Create IAM Cleanup Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install urllib3 for CloudFormation custom resource responses
        pip install urllib3 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r iam-cleanup-layer.zip python/

        echo "IAM cleanup layer created successfully"

    - name: Upload IAM Cleanup Layer
      uses: actions/upload-artifact@v4
      with:
        name: iam-cleanup-layer-package
        path: iam-cleanup-layer.zip
        retention-days: 1

    - name: Create ECS Cleanup Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install urllib3 for CloudFormation custom resource responses
        pip install urllib3 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r ecs-cleanup-layer.zip python/

        echo "ECS cleanup layer created successfully"

    - name: Upload ECS Cleanup Layer
      uses: actions/upload-artifact@v4
      with:
        name: ecs-cleanup-layer-package
        path: ecs-cleanup-layer.zip
        retention-days: 1

  build:
    name: Build and Test Applications
    needs: build-layers
    runs-on: ubuntu-latest
    outputs:
      semVer: ${{ steps.gitversion.outputs.semVer }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x

    - name: Setup GitVersion
      uses: gittools/actions/gitversion/setup@v0
      with:
        versionSpec: '5.x'

    - name: Unshallow repository if needed
      run: |
        if [ "$(git rev-parse --is-shallow-repository)" = "true" ]; then
          echo "Repository is shallow, unshallowing..."
          git fetch --unshallow
        else
          echo "Repository is not shallow"
        fi

    - name: Determine Version
      id: gitversion
      uses: gittools/actions/gitversion/execute@v0
      with:
        useConfigFile: true

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore

    - name: Build
      run: |
        echo "Building with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet build --no-restore --configuration Release /p:Version=${{ steps.gitversion.outputs.semVer }} /p:AssemblyVersion=${{ steps.gitversion.outputs.assemblySemVer }} /p:FileVersion=${{ steps.gitversion.outputs.assemblySemVer }}

    - name: Test
      run: dotnet test --no-build --verbosity normal --configuration Release

    - name: Publish API for Lambda
      run: |
        echo "Publishing API with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet publish src/TaskManager.Api/TaskManager.Api.csproj --configuration Release --output ./publish/api --runtime linux-x64 --self-contained false /p:Version=${{ steps.gitversion.outputs.semVer }}

    - name: Publish Web for Container
      run: |
        echo "Publishing Web with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet publish src/TaskManager.Web2/TaskManager.Web2.csproj --configuration Release --output ./publish/web --runtime linux-x64 --self-contained false /p:Version=${{ steps.gitversion.outputs.semVer }}

    - name: Create API Lambda deployment package
      run: |
        cd ./publish/api
        zip -r ../../api-lambda-deployment.zip .

    - name: Upload API Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: api-lambda-package
        path: api-lambda-deployment.zip

    # Global layers are now created directly by build-layers with retention
    # No need to download and re-upload them

    - name: Create MySQL Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install PyMySQL (pure Python MySQL driver)
        pip install PyMySQL -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r mysql-layer.zip python/

        echo "MySQL layer created successfully"

    - name: Upload MySQL Layer
      uses: actions/upload-artifact@v4
      with:
        name: mysql-layer-package
        path: mysql-layer.zip

    - name: Create ECR Cleanup Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install urllib3 for CloudFormation custom resource responses
        pip install urllib3 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r ecr-cleanup-layer.zip python/

        echo "ECR cleanup layer created successfully"

    - name: Upload ECR Cleanup Layer
      uses: actions/upload-artifact@v4
      with:
        name: ecr-cleanup-layer-package
        path: ecr-cleanup-layer.zip

    - name: Create S3 Cleanup Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install urllib3 for CloudFormation custom resource responses
        pip install urllib3 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r s3-cleanup-layer.zip python/

        echo "S3 cleanup layer created successfully"

    - name: Upload S3 Cleanup Layer
      uses: actions/upload-artifact@v4
      with:
        name: s3-cleanup-layer-package
        path: s3-cleanup-layer.zip

    - name: Create Security Group Cleanup Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install urllib3 for CloudFormation custom resource responses
        pip install urllib3 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r sg-cleanup-layer.zip python/

        echo "Security Group cleanup layer created successfully"

    - name: Upload Security Group Cleanup Layer
      uses: actions/upload-artifact@v4
      with:
        name: sg-cleanup-layer-package
        path: sg-cleanup-layer.zip

    # ECS cleanup layer already created by build-layers job
    # Skipping duplicate creation to avoid artifact name conflicts

  prepare-global:
    name: Prepare Global Infrastructure Dependencies
    runs-on: ubuntu-latest
    needs: [build-layers, deploy-bucket]
    concurrency:
      group: prepare-global
      cancel-in-progress: false

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Download Global Infrastructure Dependencies
      uses: actions/download-artifact@v4
      with:
        name: iam-cleanup-layer-package
        path: ./artifacts/

    - name: Download ECS Layer Dependencies
      uses: actions/download-artifact@v4
      with:
        name: ecs-cleanup-layer-package
        path: ./artifacts/

    - name: Upload Global Infrastructure Layers to S3
      run: |
        # Upload layer files required for global infrastructure
        echo "Uploading global infrastructure layer files..."
        aws s3 cp ./artifacts/iam-cleanup-layer.zip s3://${{ needs.deploy-bucket.outputs.bucket-name }}/iam-cleanup-layer.zip --region us-east-1
        aws s3 cp ./artifacts/ecs-cleanup-layer.zip s3://${{ needs.deploy-bucket.outputs.bucket-name }}/ecs-cleanup-layer.zip --region us-east-1

        # Verify uploads
        echo "Verifying S3 uploads..."
        aws s3 ls s3://${{ needs.deploy-bucket.outputs.bucket-name }}/ --region us-east-1 | grep -E "(iam-cleanup-layer|ecs-cleanup-layer)"

    - name: Verify Global Infrastructure Prerequisites
      run: |
        echo "üîç Verifying global infrastructure prerequisites..."

        # Check if IAM setup stack exists and is complete
        IAM_STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name github-actions-iam-setup \
          --region us-east-1 \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "NOT_FOUND")

        if [ "$IAM_STACK_STATUS" != "CREATE_COMPLETE" ] && [ "$IAM_STACK_STATUS" != "UPDATE_COMPLETE" ]; then
          echo "‚ùå IAM setup stack not found or not complete. Status: $IAM_STACK_STATUS"
          echo "Please ensure github-actions-iam-setup.yaml is deployed first."
          exit 1
        fi

        echo "‚úÖ IAM setup stack status: $IAM_STACK_STATUS"

        echo "üéâ Global infrastructure prerequisites verified!"

  deploy-global:
    name: Deploy Global Infrastructure
    runs-on: ubuntu-latest
    needs: prepare-global
    concurrency:
      group: deploy-global
      cancel-in-progress: false
    outputs:
      shared-lambda-role-arn: ${{ steps.deploy-global.outputs.SharedLambdaRoleArn }}
      bastion-role-arn: ${{ steps.deploy-global.outputs.BastionRoleArn }}
      database-secret-arn: ${{ steps.deploy-global.outputs.DatabaseSecretArn }}
      bastion-instance-profile-arn: ${{ steps.deploy-global.outputs.BastionInstanceProfileArn }}
      aurora-global-cluster-id: ${{ steps.deploy-global.outputs.AuroraGlobalClusterId }}
      aurora-kms-key-arn: ${{ steps.deploy-global.outputs.AuroraKmsKeyArn }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-2

    - name: Get GitHub Actions User ARN from IAM Setup Stack
      run: |
        echo "üîç Retrieving GitHub Actions User ARN from IAM setup stack in us-east-1..."

        # Get the user ARN from the IAM setup stack export
        GITHUB_USER_ARN=$(aws cloudformation list-exports \
          --region us-east-1 \
          --query "Exports[?Name=='TaskManager-GitHubActionsUserArn'].Value" \
          --output text)

        if [ -z "$GITHUB_USER_ARN" ] || [ "$GITHUB_USER_ARN" = "None" ]; then
          echo "‚ùå ERROR: Could not retrieve GitHub Actions User ARN from IAM setup stack"
          echo "Please ensure the github-actions-iam-setup stack is deployed in us-east-1"
          exit 1
        fi

        echo "‚úÖ Retrieved GitHub Actions User ARN: $GITHUB_USER_ARN"
        echo "GITHUB_ACTIONS_USER_ARN=$GITHUB_USER_ARN" >> $GITHUB_ENV

    - name: Deploy Global Infrastructure
      id: deploy-global
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-global-infrastructure
        template: infrastructure/global-template.yaml
        parameter-overrides: DatabasePassword=${{ secrets.DATABASE_PASSWORD }},EngineVersion=${{ env.ENGINE_VERSION }},GitHubActionsUserArn=${{ env.GITHUB_ACTIONS_USER_ARN }}
        capabilities: "CAPABILITY_NAMED_IAM"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 15

    - name: Verify Global Infrastructure Deployment
      run: |
        echo "üîç Verifying global infrastructure deployment..."
        aws cloudformation wait stack-create-complete \
          --stack-name taskmanager-global-infrastructure \
          --region us-east-2

        echo "‚úÖ Global infrastructure deployed successfully"
        aws cloudformation describe-stacks \
          --stack-name taskmanager-global-infrastructure \
          --region us-east-2 \
          --query 'Stacks[0].StackStatus'

  deploy-infrastructure:
    name: Deploy Regional Infrastructure
    runs-on: ubuntu-latest
    needs: [build, deploy-global, deploy-bucket]
    concurrency:
      group: deploy-infrastructure
      cancel-in-progress: false
    strategy:
      matrix:
        region: [us-east-1, us-east-2]
    outputs:
      web-ecr-repository-uri: ${{ steps.deploy-regional.outputs.WebECRRepositoryUri }}
      bastion-host-ip: ${{ steps.deploy-regional.outputs.BastionHostIP }}
      database-tunnel-command: ${{ steps.deploy-regional.outputs.DatabaseTunnelCommand }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ matrix.region }}

    - name: Download ECR and SG Cleanup Layers
      uses: actions/download-artifact@v4
      with:
        name: ecr-cleanup-layer-package
        path: ./regional-artifacts/

    - name: Download SG Cleanup Layer
      uses: actions/download-artifact@v4
      with:
        name: sg-cleanup-layer-package
        path: ./regional-artifacts/

    - name: Upload templates and regional layers to S3
      run: |
        # Upload all templates
        echo "Uploading templates to S3..."
        aws s3 cp infrastructure/regional-infrastructure.yaml s3://taskmanager-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}
        aws s3 cp src/TaskManager.Api/api-template.yaml s3://taskmanager-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}
        aws s3 cp src/TaskManager.Web2/web-template.yaml s3://taskmanager-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}
        aws s3 cp wrapper-template.yaml s3://taskmanager-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}

        # Upload regional layers required for regional infrastructure
        echo "Uploading regional layers to S3..."
        aws s3 cp ./regional-artifacts/ecr-cleanup-layer.zip s3://taskmanager-templates-bucket-${{ matrix.region }}/ecr-cleanup-layer.zip --region ${{ matrix.region }}
        aws s3 cp ./regional-artifacts/sg-cleanup-layer.zip s3://taskmanager-templates-bucket-${{ matrix.region }}/sg-cleanup-layer.zip --region ${{ matrix.region }}

        # Verify uploads
        echo "Verifying S3 uploads..."
        aws s3 ls s3://taskmanager-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }}

    - name: Validate Parameter Values
      run: |
        echo "üîç Debug: Parameter values being passed to CloudFormation:"
        echo "DatabasePassword: [REDACTED]"
        echo "SharedLambdaRoleArn: ${{ needs.deploy-global.outputs.shared-lambda-role-arn }}"
        echo "BastionRoleArn: ${{ needs.deploy-global.outputs.bastion-role-arn }}"
        echo "DatabaseSecretArn: ${{ needs.deploy-global.outputs.database-secret-arn }}"
        echo "BastionInstanceProfileArn: ${{ needs.deploy-global.outputs.bastion-instance-profile-arn }}"
        echo "AuroraGlobalClusterId: ${{ needs.deploy-global.outputs.aurora-global-cluster-id }}"

        # Validate that job outputs are not empty
        if [ -z "${{ needs.deploy-global.outputs.shared-lambda-role-arn }}" ]; then
          echo "‚ùå ERROR: SharedLambdaRoleArn is empty"
          exit 1
        fi

        if [ -z "${{ needs.deploy-global.outputs.bastion-role-arn }}" ]; then
          echo "‚ùå ERROR: BastionRoleArn is empty"
          exit 1
        fi

        if [ -z "${{ needs.deploy-global.outputs.database-secret-arn }}" ]; then
          echo "‚ùå ERROR: DatabaseSecretArn is empty"
          exit 1
        fi

        if [ -z "${{ needs.deploy-global.outputs.bastion-instance-profile-arn }}" ]; then
          echo "‚ùå ERROR: BastionInstanceProfileArn is empty"
          exit 1
        fi

        if [ -z "${{ needs.deploy-global.outputs.aurora-global-cluster-id }}" ]; then
          echo "‚ùå ERROR: AuroraGlobalClusterId is empty"
          exit 1
        fi

        echo "‚úÖ All parameter values are present, proceeding with deployment..."

    - name: Cleanup failed regional stack (if exists)
      run: |
         STACK_STATUS=$(aws cloudformation describe-stacks \
           --stack-name taskmanager-regional-infrastructure-${{ matrix.region }} \
           --region ${{ matrix.region }} \
           --query 'Stacks[0].StackStatus' \
           --output text 2>/dev/null || echo "STACK_NOT_FOUND")

         if [ "$STACK_STATUS" = "ROLLBACK_FAILED" ] || [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
           echo "üóëÔ∏è Deleting failed regional stack: taskmanager-regional-infrastructure-${{ matrix.region }}"
           aws cloudformation delete-stack \
             --stack-name taskmanager-regional-infrastructure-${{ matrix.region }} \
             --region ${{ matrix.region }}

           aws cloudformation wait stack-delete-complete \
             --stack-name taskmanager-regional-infrastructure-${{ matrix.region }} \
             --region ${{ matrix.region }}

           echo "‚úÖ Failed regional stack cleaned up"
         fi

    - name: Deploy Regional Infrastructure
      id: deploy-regional
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-regional-${{ matrix.region }}
        template: infrastructure/regional-infrastructure.yaml
        parameter-overrides: "DatabasePassword=${{ secrets.DATABASE_PASSWORD }},SharedLambdaRoleArn=${{ needs.deploy-global.outputs.shared-lambda-role-arn }},BastionRoleArn=${{ needs.deploy-global.outputs.bastion-role-arn }},DatabaseSecretArn=${{ needs.deploy-global.outputs.database-secret-arn }},BastionInstanceProfileArn=${{ needs.deploy-global.outputs.bastion-instance-profile-arn }},AuroraGlobalClusterId=${{ needs.deploy-global.outputs.aurora-global-cluster-id }},AuroraKmsKeyArn=${{ needs.deploy-global.outputs.aurora-kms-key-arn }},EngineVersion=${{ env.ENGINE_VERSION }}"
        capabilities: "CAPABILITY_NAMED_IAM"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 15

    - name: Verify Regional Infrastructure Deployment
      run: |
        echo "üîç Verifying regional infrastructure deployment in ${{ matrix.region }}..."
        aws cloudformation wait stack-create-complete \
          --stack-name taskmanager-regional-infrastructure-${{ matrix.region }} \
          --region ${{ matrix.region }}

        echo "‚úÖ Regional infrastructure deployed successfully in ${{ matrix.region }}"
        aws cloudformation describe-stacks \
          --stack-name taskmanager-regional-infrastructure-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus'

  deploy-application:
    name: Deploy Branch Application
    runs-on: ubuntu-latest
    needs: [build, deploy-infrastructure, deploy-global, yaml-lint, deploy-bucket]
    concurrency:
      group: deploy-application-${{ github.ref }}
      cancel-in-progress: false
    strategy:
      matrix:
        region: [us-east-1, us-east-2]
    outputs:
      api-endpoint: ${{ steps.get-endpoints.outputs.api-endpoint }}
      web-endpoint: ${{ steps.get-endpoints.outputs.web-endpoint }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ matrix.region }}

    - name: Build and Push Web Container Image
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      run: |
        # Use GitVersion for unique image tagging
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        IMAGE_TAG=${{ needs.build.outputs.semVer }}
        BRANCH_TAG=${BRANCH_NAME:-main}

        # Get ECR repository URI from job outputs
        ECR_REPO="${{ needs.deploy-infrastructure.outputs.web-ecr-repository-uri }}"

        # Validate ECR repo URI
        if [ -z "$ECR_REPO" ]; then
          echo "‚ùå ERROR: ECR repository URI not found in job outputs"
          exit 1
        fi

        echo "‚úÖ Successfully retrieved ECR URI from job outputs: $ECR_REPO"
        echo "üéØ Final ECR repository: $ECR_REPO"
        echo "üè∑Ô∏è Version tag: $IMAGE_TAG"
        echo "üåø Branch tag: $BRANCH_TAG"

        # Build container image from root context
        docker build -t taskmanager-web:$IMAGE_TAG -f src/TaskManager.Web2/Dockerfile .

        # Login to ECR
        aws ecr get-login-password --region ${{ matrix.region }} | docker login --username AWS --password-stdin $ECR_REPO

        # Tag and push versioned image
        docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:$IMAGE_TAG
        docker push $ECR_REPO:$IMAGE_TAG
        echo "‚úÖ Pushed versioned image: $ECR_REPO:$IMAGE_TAG"

        # Tag and push branch-specific image (for easy reference)
        docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:$BRANCH_TAG
        docker push $ECR_REPO:$BRANCH_TAG
        echo "‚úÖ Pushed branch image: $ECR_REPO:$BRANCH_TAG"

        # Also tag as latest for main branch
        if [ "$BRANCH_NAME" = "main" ]; then
          docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:latest
          docker push $ECR_REPO:latest
          echo "‚úÖ Pushed latest image: $ECR_REPO:latest"
        fi

        echo "CONTAINER_IMAGE=$ECR_REPO:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Get branch name for stack naming
      run: |
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        STACK_NAME="taskmanager-${BRANCH_NAME}"
        echo "Branch: $BRANCH_NAME"
        echo "Stack name: $STACK_NAME"
        echo "STACK_NAME=$STACK_NAME" >> $GITHUB_ENV
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

    - name: Setup SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        use-installer: true

    - name: Cleanup failed branch stack (if exists)
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }}-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")

        if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
          echo "üóëÔ∏è Deleting failed branch stack: ${{ env.STACK_NAME }}-${{ matrix.region }}"
          aws cloudformation delete-stack \
            --stack-name ${{ env.STACK_NAME }}-${{ matrix.region }} \
            --region ${{ matrix.region }}

          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.STACK_NAME }}-${{ matrix.region }} \
            --region ${{ matrix.region }}

          echo "‚úÖ Failed branch stack cleaned up"
        fi

    - name: Download Lambda packages
      uses: actions/download-artifact@v4
      with:
        name: api-lambda-package
        path: ./artifacts/

    - name: Download MySQL Layer
      uses: actions/download-artifact@v4
      with:
        name: mysql-layer-package
        path: ./artifacts/

    - name: Download S3 Cleanup Layer
      uses: actions/download-artifact@v4
      with:
        name: s3-cleanup-layer-package
        path: ./artifacts/

    - name: Download IAM Cleanup Layer
      uses: actions/download-artifact@v4
      with:
        name: iam-cleanup-layer-package
        path: ./artifacts/

    - name: Download ECS Cleanup Layer
      uses: actions/download-artifact@v4
      with:
        name: ecs-cleanup-layer-package
        path: ./artifacts/

    - name: Upload templates and packages to S3
      run: |
        # Debug: List downloaded artifacts
        echo "Downloaded artifacts:"
        ls -la ./artifacts/

        # Upload Lambda deployment packages
        aws s3 cp ./artifacts/api-lambda-deployment.zip s3://taskmanager-templates-bucket-${{ matrix.region }}/api-lambda-deployment.zip --region ${{ matrix.region }}

        # Upload MySQL layer
        aws s3 cp ./artifacts/mysql-layer.zip s3://taskmanager-templates-bucket-${{ matrix.region }}/mysql-layer.zip --region ${{ matrix.region }}

        # Upload S3 cleanup layer
        aws s3 cp ./artifacts/s3-cleanup-layer.zip s3://taskmanager-templates-bucket-${{ matrix.region }}/s3-cleanup-layer.zip --region ${{ matrix.region }}

        # Upload IAM cleanup layer
        aws s3 cp ./artifacts/iam-cleanup-layer.zip s3://taskmanager-templates-bucket-${{ matrix.region }}/iam-cleanup-layer.zip --region ${{ matrix.region }}

        # Upload ECS cleanup layer
        aws s3 cp ./artifacts/ecs-cleanup-layer.zip s3://taskmanager-templates-bucket-${{ matrix.region }}/ecs-cleanup-layer.zip --region ${{ matrix.region }}

        # Verify uploads
        echo "S3 bucket contents:"
        aws s3 ls s3://taskmanager-templates-bucket-${{ matrix.region }}/ --region ${{ matrix.region }} | grep -E "(api-lambda-deployment|mysql-layer|s3-cleanup-layer|iam-cleanup-layer|ecs-cleanup-layer)"

    - name: Deploy Wrapper Template (Nested Stacks)
      id: deploy-wrapper
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: ${{ env.STACK_NAME }}-${{ matrix.region }}
        template: wrapper-template.yaml
        parameter-overrides: Environment=${{ env.BRANCH_NAME }},ApiCodeBucket=taskmanager-templates-bucket-${{ matrix.region }},WebContainerImage=${{ env.CONTAINER_IMAGE }},DeploymentToken=${{ github.sha }},DomainName=appcloud.systems,HostedZoneId=Z06422172SASV44F5Y8VA,DatabasePassword=${{ secrets.DATABASE_PASSWORD }},TemplatesBucket=taskmanager-templates-bucket-${{ matrix.region }}
        capabilities: "CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 20

    - name: Verify Application Deployment
      run: |
        echo "üîç Verifying application deployment in ${{ matrix.region }}..."
        aws cloudformation wait stack-create-complete \
          --stack-name ${{ env.STACK_NAME }}-${{ matrix.region }} \
          --region ${{ matrix.region }}

        echo "‚úÖ Application deployed successfully in ${{ matrix.region }}"
        aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }}-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus'

    - name: Setup branch database
      run: |
        echo "Setting up database for branch: ${{ env.BRANCH_NAME }}"

        # Get API endpoint from wrapper stack outputs
        API_URL="${{ steps.deploy-wrapper.outputs.ApiEndpoint }}"

        if [ -z "$API_URL" ]; then
          echo "‚ùå API endpoint not found in stack outputs"
          echo "This indicates the CloudFormation deployment failed or the output is not ready"
          exit 1
        fi

        echo "‚úÖ API endpoint from stack outputs: $API_URL"

        # Test API connectivity first
        echo "Testing API connectivity..."
        HEALTH_CHECK_CMD="curl -f -s --max-time 30 \"$API_URL/health\""
        echo "Executing: $HEALTH_CHECK_CMD"
        if ! eval "$HEALTH_CHECK_CMD" > /dev/null; then
          echo "‚ùå API health check failed"
          exit 1
        fi
        echo "‚úÖ API is healthy"

        # Setup database with token authentication
        echo "Setting up database..."
        DB_SETUP_CMD="curl -s -w \"\nHTTP_STATUS:%{http_code}\" -X POST \"${API_URL}setup-database\" -H \"Authorization: taskmanager-setup-secure-token-2024\" --max-time 60"
        echo "Executing: $DB_SETUP_CMD"
        DB_SETUP_RESPONSE=$(eval "$DB_SETUP_CMD")

        HTTP_STATUS=$(echo "$DB_SETUP_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
        RESPONSE_BODY=$(echo "$DB_SETUP_RESPONSE" | sed '/HTTP_STATUS:/d')

        echo "Database setup response: $RESPONSE_BODY"
        echo "HTTP Status: $HTTP_STATUS"

        if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ]; then
          echo "‚úÖ Database setup completed successfully"
        else
          echo "‚ùå Database setup failed with HTTP status: $HTTP_STATUS"
          exit 1
        fi

    - name: Get deployment outputs
      id: get-endpoints
      run: |
        echo "Getting deployment outputs from stack outputs..."

        # Get API endpoint from wrapper stack outputs
        API_URL="${{ steps.deploy-wrapper.outputs.TaskManagerApiEndpoint }}"

        if [ -z "$API_URL" ]; then
          echo "‚ùå API endpoint not found in stack outputs"
          exit 1
        fi
        echo "‚úÖ API endpoint: $API_URL"

        # Get Web endpoint from wrapper stack outputs
        WEB_URL="${{ steps.deploy-wrapper.outputs.WebLoadBalancerDNS }}"

        if [ -z "$WEB_URL" ]; then
          echo "‚ö†Ô∏è Web endpoint not found in stack outputs"
          WEB_URL=""
        else
          echo "‚úÖ Web endpoint: $WEB_URL"
        fi

        BASTION_IP="${{ needs.deploy-infrastructure.outputs.bastion-host-ip }}"
        TUNNEL_CMD="${{ needs.deploy-infrastructure.outputs.database-tunnel-command }}"

        # Extract API Gateway ID from URL
        API_GATEWAY_ID=$(echo $API_URL | sed 's|https://||' | sed 's|\.execute-api.*||')

        echo "üöÄ TaskManager (${{ env.BRANCH_NAME }}) deployed successfully in ${{ matrix.region }}!"
        echo "üìã API Stack: ${{ env.STACK_NAME }}-${{ matrix.region }}-api ‚úÖ Endpoint: $API_URL"
        echo "üìã Web Stack: ${{ env.STACK_NAME }}-${{ matrix.region }}-web ‚úÖ Load Balancer: $WEB_URL"
        echo "üñ•Ô∏è Bastion host IP: $BASTION_IP"
        echo "üíæ Database: taskmanager_${{ env.BRANCH_NAME }} ‚úÖ Setup verified"
        echo "üîó SSH Tunnel: $TUNNEL_CMD"

        # Set outputs for other jobs
        echo "api-endpoint=$API_URL" >> $GITHUB_OUTPUT
        echo "web-endpoint=$WEB_URL" >> $GITHUB_OUTPUT
        echo "api-gateway-id=$API_GATEWAY_ID" >> $GITHUB_OUTPUT

    - name: Send SMS Notification
      run: |
        # Note: SMS notification disabled as SNS topic is not defined in global template
        echo "üì± SMS notification skipped - SNS topic not configured in global infrastructure"
        echo "üöÄ TaskManager deployment complete! Branch: ${{ env.BRANCH_NAME }} Region: ${{ matrix.region }} API: $API_URL Web App: https://$BRANCH_NAME.appcloud.systems Database: taskmanager_${{ env.BRANCH_NAME }} ‚úÖ Setup verified Bastion IP: $BASTION_IP Both API and Web are fully deployed and running!"

  verify-deployments:
    name: Verify All Deployments
    runs-on: ubuntu-latest
    needs: [deploy-application, deploy-global]
    if: success()
    strategy:
      matrix:
        region: [us-east-1, us-east-2]

    steps:
    - name: Verify Deployment Status
      run: |
        echo "üîç Final verification of all deployments in ${{ matrix.region }}..."

        # Check global infrastructure (only for us-east-1)
        if [ "${{ matrix.region }}" = "us-east-1" ]; then
          echo "Checking global infrastructure..."
          GLOBAL_STATUS=$(aws cloudformation describe-stacks \
            --stack-name taskmanager-global-infrastructure \
            --region us-east-1 \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "NOT_FOUND")

          if [ "$GLOBAL_STATUS" != "CREATE_COMPLETE" ] && [ "$GLOBAL_STATUS" != "UPDATE_COMPLETE" ]; then
            echo "‚ùå Global infrastructure deployment failed: $GLOBAL_STATUS"
            exit 1
          fi
          echo "‚úÖ Global infrastructure: $GLOBAL_STATUS"
        fi

        # Check regional infrastructure
        echo "Checking regional infrastructure..."
        REGIONAL_STATUS=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-regional-infrastructure-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "NOT_FOUND")

        if [ "$REGIONAL_STATUS" != "CREATE_COMPLETE" ] && [ "$REGIONAL_STATUS" != "UPDATE_COMPLETE" ]; then
          echo "‚ùå Regional infrastructure deployment failed: $REGIONAL_STATUS"
          exit 1
        fi
        echo "‚úÖ Regional infrastructure: $REGIONAL_STATUS"

        # Check application deployment
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        STACK_NAME="taskmanager-${BRANCH_NAME}"

        echo "Checking application deployment..."
        APP_STATUS=$(aws cloudformation describe-stacks \
          --stack-name ${STACK_NAME}-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "NOT_FOUND")

        if [ "$APP_STATUS" != "CREATE_COMPLETE" ] && [ "$APP_STATUS" != "UPDATE_COMPLETE" ]; then
          echo "‚ùå Application deployment failed: $APP_STATUS"
          exit 1
        fi
        echo "‚úÖ Application deployment: $APP_STATUS"

        echo "üéâ All deployments verified successfully in ${{ matrix.region }}!"

  update-google-oauth:
    name: Generate Google OAuth Update Instructions
    runs-on: ubuntu-latest
    needs: [deploy-application, verify-deployments]
    if: needs.deploy-application.result == 'success' && needs.verify-deployments.result == 'success'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Update Google OAuth Configuration
      run: |
        chmod +x update-google-oauth.sh
        ./update-google-oauth.sh "${{ needs.deploy-application.outputs.api-endpoint }}" "${{ needs.deploy-application.outputs.web-endpoint }}"
