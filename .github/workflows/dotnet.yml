# TaskManager CI/CD Pipeline - Shared Infrastructure + Branch Applications

name: TaskManager CI/CD

on:
  push:
  pull_request:

env:
  AWS_REGION: us-east-1
  AWS_REGION_2: us-east-2

jobs:
  yaml-lint:
    name: YAML Lint
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Install yamllint
      run: pip install yamllint
      
    - name: Lint YAML files
      run: |
        echo "Linting all .yml and .yaml files in the repository (excluding .github/workflows/dotnet.yml)..."
        find . -name "*.yml" -o -name "*.yaml" | grep -v ".github/workflows/dotnet.yml" | while read file; do
          echo "Linting: $file"
          yamllint -c .yamllint.yml "$file"
        done
        
        # Check if any linting errors occurred
        if find . -name "*.yml" -o -name "*.yaml" | grep -v ".github/workflows/dotnet.yml" | xargs yamllint -c .yamllint.yml | grep -q "error"; then
          echo "âŒ YAML linting failed!"
          exit 1
        else
          echo "âœ… All YAML files passed linting!"
        fi

  build:
    name: Build and Test
    runs-on: ubuntu-latest
    outputs:
      semVer: ${{ steps.gitversion.outputs.semVer }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x

    - name: Setup GitVersion
      uses: gittools/actions/gitversion/setup@v0
      with:
        versionSpec: '5.x'

    - name: Unshallow repository if needed
      run: |
        if [ "$(git rev-parse --is-shallow-repository)" = "true" ]; then
          echo "Repository is shallow, unshallowing..."
          git fetch --unshallow
        else
          echo "Repository is not shallow"
        fi

    - name: Determine Version
      id: gitversion
      uses: gittools/actions/gitversion/execute@v0
      with:
        useConfigFile: true

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore
      
    - name: Build
      run: |
        echo "Building with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet build --no-restore --configuration Release /p:Version=${{ steps.gitversion.outputs.semVer }} /p:AssemblyVersion=${{ steps.gitversion.outputs.assemblySemVer }} /p:FileVersion=${{ steps.gitversion.outputs.assemblySemVer }}
      
    - name: Test
      run: dotnet test --no-build --verbosity normal --configuration Release
      
    - name: Publish API for Lambda
      run: |
        echo "Publishing API with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet publish src/TaskManager.Api/TaskManager.Api.csproj --configuration Release --output ./publish/api --runtime linux-x64 --self-contained false /p:Version=${{ steps.gitversion.outputs.semVer }}

    - name: Publish Web for Container
      run: |
        echo "Publishing Web with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet publish src/TaskManager.Web2/TaskManager.Web2.csproj --configuration Release --output ./publish/web --runtime linux-x64 --self-contained false /p:Version=${{ steps.gitversion.outputs.semVer }}

    - name: Create API Lambda deployment package
      run: |
        cd ./publish/api
        zip -r ../../api-lambda-deployment.zip .

    - name: Upload API Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: api-lambda-package
        path: api-lambda-deployment.zip

    - name: Create PostgreSQL Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install pg8000 (pure Python PostgreSQL driver)
        pip install pg8000 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r postgres-layer.zip python/

        echo "PostgreSQL layer created successfully"

    - name: Upload PostgreSQL Layer
      uses: actions/upload-artifact@v4
      with:
        name: postgres-layer-package
        path: postgres-layer.zip

    - name: Create ECR Cleanup Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install urllib3 for CloudFormation custom resource responses
        pip install urllib3 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r ecr-cleanup-layer.zip python/

        echo "ECR cleanup layer created successfully"

    - name: Upload ECR Cleanup Layer
      uses: actions/upload-artifact@v4
      with:
        name: ecr-cleanup-layer-package
        path: ecr-cleanup-layer.zip

    - name: Create S3 Cleanup Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install urllib3 for CloudFormation custom resource responses
        pip install urllib3 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r s3-cleanup-layer.zip python/

        echo "S3 cleanup layer created successfully"

    - name: Upload S3 Cleanup Layer
      uses: actions/upload-artifact@v4
      with:
        name: s3-cleanup-layer-package
        path: s3-cleanup-layer.zip

    - name: Create IAM Cleanup Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install urllib3 for CloudFormation custom resource responses
        pip install urllib3 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r iam-cleanup-layer.zip python/

        echo "IAM cleanup layer created successfully"

    - name: Upload IAM Cleanup Layer
      uses: actions/upload-artifact@v4
      with:
        name: iam-cleanup-layer-package
        path: iam-cleanup-layer.zip

    - name: Create Security Group Cleanup Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install urllib3 for CloudFormation custom resource responses
        pip install urllib3 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r sg-cleanup-layer.zip python/

        echo "Security Group cleanup layer created successfully"

    - name: Upload Security Group Cleanup Layer
      uses: actions/upload-artifact@v4
      with:
        name: sg-cleanup-layer-package
        path: sg-cleanup-layer.zip

    - name: Create ECS Cleanup Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install urllib3 for CloudFormation custom resource responses
        pip install urllib3 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r ecs-cleanup-layer.zip python/

        echo "ECS cleanup layer created successfully"

    - name: Upload ECS Cleanup Layer
      uses: actions/upload-artifact@v4
      with:
        name: ecs-cleanup-layer-package
        path: ecs-cleanup-layer.zip

  deploy-global:
    name: Deploy Global Infrastructure
    runs-on: ubuntu-latest
    needs: build
    concurrency:
      group: deploy-global
      cancel-in-progress: false

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Download Lambda layer artifacts
      uses: actions/download-artifact@v4
      with:
        name: iam-cleanup-layer-package
        path: ./artifacts/

    - name: Download ECS layer artifacts
      uses: actions/download-artifact@v4
      with:
        name: ecs-cleanup-layer-package
        path: ./artifacts/

    - name: Upload Lambda layers to S3
      run: |
        # Get bucket name from IAM setup stack export
        BUCKET_NAME=$(aws cloudformation list-exports \
          --query "Exports[?Name=='TaskManager-TemplatesBucket'].Value" \
          --output text \
          --region us-east-1)

        if [ -z "$BUCKET_NAME" ] || [ "$BUCKET_NAME" = "None" ]; then
          echo "âŒ TaskManager-TemplatesBucket export not found. Please ensure github-actions-iam-setup.yaml is deployed first."
          exit 1
        fi

        echo "Using S3 bucket: $BUCKET_NAME"

        # Upload layer files
        echo "Uploading Lambda layer files..."
        aws s3 cp ./artifacts/iam-cleanup-layer.zip s3://$BUCKET_NAME/iam-cleanup-layer.zip --region us-east-1
        aws s3 cp ./artifacts/ecs-cleanup-layer.zip s3://$BUCKET_NAME/ecs-cleanup-layer.zip --region us-east-1

        # Verify uploads
        echo "Verifying S3 uploads..."
        aws s3 ls s3://$BUCKET_NAME/ --region us-east-1

        # Export bucket name for use in subsequent steps
        echo "TEMPLATE_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV

    - name: Deploy Global Infrastructure
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-global-infrastructure
        template: infrastructure/global-template.yaml
        parameter-overrides: |
          DatabasePassword=${{ secrets.DATABASE_PASSWORD }}
        capabilities: "CAPABILITY_NAMED_IAM"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 15

  deploy-infrastructure:
    name: Deploy Regional Infrastructure
    runs-on: ubuntu-latest
    needs: [build, deploy-global]
    concurrency:
      group: deploy-infrastructure
      cancel-in-progress: false
    strategy:
      matrix:
        region: [us-east-1, us-east-2]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ matrix.region }}

    - name: Upload templates to S3
      run: |
        # Get bucket name from global stack export
        BUCKET_NAME=$(aws cloudformation list-exports \
          --query "Exports[?Name=='TaskManager-TemplatesBucket'].Value" \
          --output text \
          --region us-east-1)

        if [ -z "$BUCKET_NAME" ] || [ "$BUCKET_NAME" = "None" ]; then
          echo "âŒ TaskManager-TemplatesBucket export not found. Please ensure taskmanager-global-infrastructure stack is deployed."
          exit 1
        fi

        echo "Using S3 bucket: $BUCKET_NAME"

        # Upload all templates
        echo "Uploading templates to S3..."
        aws s3 cp infrastructure/shared-infrastructure.yaml s3://$BUCKET_NAME/ --region us-east-1
        aws s3 cp src/TaskManager.Api/api-template.yaml s3://$BUCKET_NAME/ --region us-east-1
        aws s3 cp src/TaskManager.Web2/web-template.yaml s3://$BUCKET_NAME/ --region us-east-1
        aws s3 cp wrapper-template.yaml s3://$BUCKET_NAME/ --region us-east-1

        # Verify uploads
        echo "Verifying S3 uploads..."
        aws s3 ls s3://$BUCKET_NAME/ --region us-east-1

        # Export bucket name for use in subsequent steps
        echo "TEMPLATE_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV

    - name: Deploy Regional Infrastructure
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-regional-infrastructure-${{ matrix.region }}
        template: infrastructure/shared-infrastructure.yaml
        parameter-overrides: |
          DatabasePassword=${{ secrets.DATABASE_PASSWORD }},
          SharedLambdaRoleArn=arn:aws:iam::$ACCOUNT_ID:role/TaskManager-Shared-Lambda-Role,
          BastionRoleArn=arn:aws:iam::$ACCOUNT_ID:role/TaskManager-Bastion-Role,
          DatabaseSecretArn=arn:aws:secretsmanager:us-east-1:$ACCOUNT_ID:secret:taskmanager/database/shared
        capabilities: "CAPABILITY_NAMED_IAM"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 15

  deploy-application:
    name: Deploy Branch Application
    runs-on: ubuntu-latest
    needs: [build, deploy-infrastructure, yaml-lint]
    concurrency:
      group: deploy-application-${{ github.ref }}
      cancel-in-progress: false
    strategy:
      matrix:
        region: [us-east-1, us-east-2]
    outputs:
      api-endpoint: ${{ steps.get-endpoints.outputs.api-endpoint }}
      web-endpoint: ${{ steps.get-endpoints.outputs.web-endpoint }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ matrix.region }}

    - name: Build and Push Web Container Image
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      run: |
        # Use GitVersion for unique image tagging
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        IMAGE_TAG=${{ needs.build.outputs.semVer }}
        BRANCH_TAG=${BRANCH_NAME:-main}

        # Get ECR repository URI from CloudFormation outputs
        echo "Querying CloudFormation for ECR repository URI..."
        ECR_REPO=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-regional-infrastructure-${{ matrix.region }} \
          --query 'Stacks[0].Outputs[?OutputKey==`WebECRRepositoryUri`].OutputValue' \
          --output text \
          --region ${{ matrix.region }} 2>/dev/null || echo "")

        # Debug: Show what we got from CloudFormation
        echo "CloudFormation query result: '$ECR_REPO'"

        # Fallback: construct ECR repo URI if CloudFormation query fails
        if [ -z "$ECR_REPO" ] || [ "$ECR_REPO" = "None" ] || [ "$ECR_REPO" = "null" ]; then
          echo "âŒ CloudFormation ECR query failed or returned empty, using fallback URI"
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPO="$ACCOUNT_ID.dkr.ecr.${{ matrix.region }}.amazonaws.com/taskmanager-web"
          echo "ðŸ“ Constructed fallback ECR URI: $ECR_REPO"
        else
          echo "âœ… Successfully retrieved ECR URI from CloudFormation: $ECR_REPO"
        fi

        echo "ðŸŽ¯ Final ECR repository: $ECR_REPO"
        echo "ðŸ·ï¸ Version tag: $IMAGE_TAG"
        echo "ðŸŒ¿ Branch tag: $BRANCH_TAG"

        # Build container image from root context
        docker build -t taskmanager-web:$IMAGE_TAG -f src/TaskManager.Web2/Dockerfile .

        # Login to ECR
        aws ecr get-login-password --region ${{ matrix.region }} | docker login --username AWS --password-stdin $ECR_REPO

        # Tag and push versioned image
        docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:$IMAGE_TAG
        docker push $ECR_REPO:$IMAGE_TAG
        echo "âœ… Pushed versioned image: $ECR_REPO:$IMAGE_TAG"

        # Tag and push branch-specific image (for easy reference)
        docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:$BRANCH_TAG
        docker push $ECR_REPO:$BRANCH_TAG
        echo "âœ… Pushed branch image: $ECR_REPO:$BRANCH_TAG"

        # Also tag as latest for main branch
        if [ "$BRANCH_NAME" = "main" ]; then
          docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:latest
          docker push $ECR_REPO:latest
          echo "âœ… Pushed latest image: $ECR_REPO:latest"
        fi

        echo "CONTAINER_IMAGE=$ECR_REPO:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Get branch name for stack naming
      run: |
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        STACK_NAME="taskmanager-${BRANCH_NAME}"
        echo "Branch: $BRANCH_NAME"
        echo "Stack name: $STACK_NAME"
        echo "STACK_NAME=$STACK_NAME" >> $GITHUB_ENV
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
        
    - name: Setup SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        use-installer: true
        
    - name: Cleanup failed branch stack (if exists)
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }}-${{ matrix.region }} \
          --region ${{ matrix.region }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")

        if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
          echo "ðŸ—‘ï¸ Deleting failed branch stack: ${{ env.STACK_NAME }}-${{ matrix.region }}"
          aws cloudformation delete-stack \
            --stack-name ${{ env.STACK_NAME }}-${{ matrix.region }} \
            --region ${{ matrix.region }}

          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.STACK_NAME }}-${{ matrix.region }} \
            --region ${{ matrix.region }}

          echo "âœ… Failed branch stack cleaned up"
        fi
        
    - name: Download Lambda packages
      uses: actions/download-artifact@v4
      with:
        name: api-lambda-package
        path: ./artifacts/

    - name: Download PostgreSQL Layer
      uses: actions/download-artifact@v4
      with:
        name: postgres-layer-package
        path: ./artifacts/

    - name: Download ECR Cleanup Layer
      uses: actions/download-artifact@v4
      with:
        name: ecr-cleanup-layer-package
        path: ./artifacts/

    - name: Download S3 Cleanup Layer
      uses: actions/download-artifact@v4
      with:
        name: s3-cleanup-layer-package
        path: ./artifacts/

    - name: Download IAM Cleanup Layer
      uses: actions/download-artifact@v4
      with:
        name: iam-cleanup-layer-package
        path: ./artifacts/

    - name: Download Security Group Cleanup Layer
      uses: actions/download-artifact@v4
      with:
        name: sg-cleanup-layer-package
        path: ./artifacts/

    - name: Download ECS Cleanup Layer
      uses: actions/download-artifact@v4
      with:
        name: ecs-cleanup-layer-package
        path: ./artifacts/


    - name: Upload templates and packages to S3
      run: |
        # Get bucket name from IAM setup stack export
        BUCKET_NAME=$(aws cloudformation list-exports \
          --query "Exports[?Name=='TaskManager-TemplatesBucket'].Value" \
          --output text \
          --region us-east-1)

        if [ -z "$BUCKET_NAME" ] || [ "$BUCKET_NAME" = "None" ]; then
          echo "âŒ TaskManager-TemplatesBucket export not found. Please ensure github-actions-iam-setup.yaml is deployed first."
          exit 1
        fi

        echo "Using S3 bucket: $BUCKET_NAME"

        # Debug: List downloaded artifacts
        echo "Downloaded artifacts:"
        ls -la ./artifacts/

        # Upload Lambda deployment packages
        aws s3 cp ./artifacts/api-lambda-deployment.zip s3://$BUCKET_NAME/api-lambda-deployment.zip --region us-east-1

        # Upload PostgreSQL layer
        aws s3 cp ./artifacts/postgres-layer.zip s3://$BUCKET_NAME/postgres-layer.zip --region us-east-1

        # Upload ECR cleanup layer
        aws s3 cp ./artifacts/ecr-cleanup-layer.zip s3://$BUCKET_NAME/ecr-cleanup-layer.zip --region us-east-1

        # Upload S3 cleanup layer
        aws s3 cp ./artifacts/s3-cleanup-layer.zip s3://$BUCKET_NAME/s3-cleanup-layer.zip --region us-east-1

        # Upload IAM cleanup layer
        aws s3 cp ./artifacts/iam-cleanup-layer.zip s3://$BUCKET_NAME/iam-cleanup-layer.zip --region us-east-1

        # Upload Security Group cleanup layer
        aws s3 cp ./artifacts/sg-cleanup-layer.zip s3://$BUCKET_NAME/sg-cleanup-layer.zip --region us-east-1

        # Upload ECS cleanup layer
        aws s3 cp ./artifacts/ecs-cleanup-layer.zip s3://$BUCKET_NAME/ecs-cleanup-layer.zip --region us-east-1

        # Verify uploads
        echo "S3 bucket contents:"
        aws s3 ls s3://$BUCKET_NAME/ --region us-east-1

        echo "TEMPLATE_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV

    - name: Deploy Wrapper Template (Nested Stacks)
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: ${{ env.STACK_NAME }}-${{ matrix.region }}
        template: wrapper-template.yaml
        parameter-overrides: |
          Environment=${{ env.BRANCH_NAME }},
          ApiCodeBucket=${{ env.TEMPLATE_BUCKET }},
          WebContainerImage=${{ env.CONTAINER_IMAGE }},
          DeploymentToken=${{ github.sha }},
          DomainName=appcloud.systems,
          HostedZoneId=Z06422172SASV44F5Y8VA,
          DatabasePassword=${{ secrets.DATABASE_PASSWORD }}
        capabilities: "CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 20

    - name: Setup branch database
      run: |
        echo "Setting up database for branch: ${{ env.BRANCH_NAME }}"

        # Get API endpoint from wrapper stack exports (most reliable method)
        # The wrapper stack exports the API endpoint with name: TaskManager-{Environment}-ApiEndpoint
        EXPORT_NAME="TaskManager-${{ env.BRANCH_NAME }}-ApiEndpoint"

        echo "Looking for CloudFormation export: $EXPORT_NAME"
        API_URL=$(aws cloudformation list-exports \
          --query "Exports[?Name=='$EXPORT_NAME'].Value" \
          --output text \
          --region ${{ matrix.region }} 2>/dev/null || echo "")

        if [ -z "$API_URL" ] || [ "$API_URL" = "None" ]; then
          echo "âŒ API endpoint export not found: $EXPORT_NAME"
          echo "This indicates the CloudFormation deployment failed or the export is not ready"
          exit 1
        fi

        echo "âœ… API endpoint from export: $API_URL"

        # Test API connectivity first
        echo "Testing API connectivity..."
        HEALTH_CHECK_CMD="curl -f -s --max-time 30 \"$API_URL/health\""
        echo "Executing: $HEALTH_CHECK_CMD"
        if ! eval "$HEALTH_CHECK_CMD" > /dev/null; then
          echo "âŒ API health check failed"
          exit 1
        fi
        echo "âœ… API is healthy"

        # Setup database with token authentication
        echo "Setting up database..."
        DB_SETUP_CMD="curl -s -w \"\nHTTP_STATUS:%{http_code}\" -X POST \"${API_URL}setup-database\" -H \"Authorization: taskmanager-setup-secure-token-2024\" --max-time 60"
        echo "Executing: $DB_SETUP_CMD"
        DB_SETUP_RESPONSE=$(eval "$DB_SETUP_CMD")

        HTTP_STATUS=$(echo "$DB_SETUP_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
        RESPONSE_BODY=$(echo "$DB_SETUP_RESPONSE" | sed '/HTTP_STATUS:/d')

        echo "Database setup response: $RESPONSE_BODY"
        echo "HTTP Status: $HTTP_STATUS"

        if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ]; then
          echo "âœ… Database setup completed successfully"
        else
          echo "âŒ Database setup failed with HTTP status: $HTTP_STATUS"
          exit 1
        fi

    - name: Get deployment outputs
      id: get-endpoints
      run: |
        echo "Getting deployment outputs from CloudFormation exports..."

        # Get API endpoint from wrapper stack exports
        API_EXPORT_NAME="TaskManager-${{ env.BRANCH_NAME }}-ApiEndpoint"
        API_URL=$(aws cloudformation list-exports \
          --query "Exports[?Name=='$API_EXPORT_NAME'].Value" \
          --output text \
          --region ${{ matrix.region }} 2>/dev/null || echo "")

        if [ -z "$API_URL" ] || [ "$API_URL" = "None" ]; then
          echo "âŒ API endpoint export not found: $API_EXPORT_NAME"
          echo "Available exports:"
          aws cloudformation list-exports --region ${{ matrix.region }} 2>/dev/null || echo "No exports found"
          exit 1
        fi
        echo "âœ… API endpoint: $API_URL"

        # Get Web endpoint from wrapper stack exports
        WEB_EXPORT_NAME="TaskManager-${{ env.BRANCH_NAME }}-WebLoadBalancerDNS"
        WEB_URL=$(aws cloudformation list-exports \
          --query "Exports[?Name=='$WEB_EXPORT_NAME'].Value" \
          --output text \
          --region ${{ matrix.region }} 2>/dev/null || echo "")

        if [ -z "$WEB_URL" ] || [ "$WEB_URL" = "None" ]; then
          echo "âš ï¸ Web endpoint export not found: $WEB_EXPORT_NAME"
          WEB_URL=""
        else
          echo "âœ… Web endpoint: $WEB_URL"
        fi

        BASTION_IP=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-regional-infrastructure-${{ matrix.region }} \
          --query 'Stacks[0].Outputs[?OutputKey==`BastionHostIP`].OutputValue' \
          --output text \
          --region ${{ matrix.region }})

        TUNNEL_CMD=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-regional-infrastructure-${{ matrix.region }} \
          --query 'Stacks[0].Outputs[?OutputKey==`DatabaseTunnelCommand`].OutputValue' \
          --output text \
          --region ${{ matrix.region }})

        # Extract API Gateway ID from URL
        API_GATEWAY_ID=$(echo $API_URL | sed 's|https://||' | sed 's|\.execute-api.*||')

        echo "ðŸš€ TaskManager (${{ env.BRANCH_NAME }}) deployed successfully in ${{ matrix.region }}!"
        echo "ðŸ“‹ API Stack: ${{ env.STACK_NAME }}-${{ matrix.region }}-api âœ… Endpoint: $API_URL"
        echo "ðŸ“‹ Web Stack: ${{ env.STACK_NAME }}-${{ matrix.region }}-web âœ… Load Balancer: $WEB_URL"
        echo "ðŸ–¥ï¸ Bastion host IP: $BASTION_IP"
        echo "ðŸ’¾ Database: taskmanager_${{ env.BRANCH_NAME }} âœ… Setup verified"
        echo "ðŸ”— SSH Tunnel: $TUNNEL_CMD"

        # Set outputs for other jobs
        echo "api-endpoint=$API_URL" >> $GITHUB_OUTPUT
        echo "web-endpoint=$WEB_URL" >> $GITHUB_OUTPUT
        echo "api-gateway-id=$API_GATEWAY_ID" >> $GITHUB_OUTPUT

    - name: Send SMS Notification
      run: |
        # Get SNS topic ARN from global stack (always in us-east-1)
        SNS_TOPIC=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-global-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`DeploymentNotificationTopicArn`].OutputValue' \
          --output text \
          --region us-east-1)

        # Send SMS notification
        aws sns publish \
          --topic-arn $SNS_TOPIC \
          --message "ðŸš€ TaskManager deployment complete!

        Branch: ${{ env.BRANCH_NAME }}
        Region: ${{ matrix.region }}
        API: $API_URL
        Web App: https://$BRANCH_NAME.appcloud.systems
        Database: taskmanager_${{ env.BRANCH_NAME }} âœ… Setup verified
        Bastion IP: $BASTION_IP

        Both API and Web are fully deployed and running!" \
          --subject "TaskManager Deployed - ${{ env.BRANCH_NAME }} (${{ matrix.region }})" \
          --region us-east-1

        echo "ðŸ“± SMS notification sent to 703-474-0324"

  update-google-oauth:
    name: Generate Google OAuth Update Instructions
    runs-on: ubuntu-latest
    needs: deploy-application
    if: needs.deploy-application.result == 'success'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Update Google OAuth Configuration
      run: |
        chmod +x update-google-oauth.sh
        ./update-google-oauth.sh "${{ needs.deploy-application.outputs.api-endpoint }}" "${{ needs.deploy-application.outputs.web-endpoint }}"
