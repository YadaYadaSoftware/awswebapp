# TaskManager CI/CD Pipeline - Shared Infrastructure + Branch Applications

name: TaskManager CI/CD

on:
  push:
  pull_request:

env:
  AWS_REGION: us-east-1

jobs:
  yaml-lint:
    name: YAML Lint
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Install yamllint
      run: pip install yamllint
      
    - name: Lint YAML files
      run: |
        echo "Linting all .yml and .yaml files in the repository (excluding .github/workflows/dotnet.yml)..."
        find . -name "*.yml" -o -name "*.yaml" | grep -v ".github/workflows/dotnet.yml" | while read file; do
          echo "Linting: $file"
          yamllint -c .yamllint.yml "$file"
        done
        
        # Check if any linting errors occurred
        if find . -name "*.yml" -o -name "*.yaml" | grep -v ".github/workflows/dotnet.yml" | xargs yamllint -c .yamllint.yml | grep -q "error"; then
          echo "‚ùå YAML linting failed!"
          exit 1
        else
          echo "‚úÖ All YAML files passed linting!"
        fi

  build:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
        
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
          
    - name: Restore dependencies
      run: dotnet restore
      
    - name: Build
      run: dotnet build --no-restore --configuration Release
      
    - name: Test
      run: dotnet test --no-build --verbosity normal --configuration Release
      
    - name: Publish API for Lambda
      run: dotnet publish src/TaskManager.Api/TaskManager.Api.csproj --configuration Release --output ./publish/api --runtime linux-x64 --self-contained false

    - name: Publish Web for Container
      run: dotnet publish src/TaskManager.Web/TaskManager.Web.csproj --configuration Release --output ./publish/web --runtime linux-x64 --self-contained false

    - name: Create API Lambda deployment package
      run: |
        cd ./publish/api
        zip -r ../../api-lambda-deployment.zip .

    - name: Upload API Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: api-lambda-package
        path: api-lambda-deployment.zip

  deploy-infrastructure:
    name: Deploy Shared Infrastructure
    runs-on: ubuntu-latest
    needs: build
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Deploy Shared Infrastructure
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-shared-infrastructure
        template: infrastructure/shared-infrastructure.yaml
        parameter-overrides: |
          DatabasePassword=${{ secrets.DATABASE_PASSWORD }}
        capabilities: "CAPABILITY_NAMED_IAM"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 15

  deploy-application:
    name: Deploy Branch Application
    runs-on: ubuntu-latest
    needs: [build, deploy-infrastructure, yaml-lint]
    outputs:
      api-endpoint: ${{ steps.get-endpoints.outputs.api-endpoint }}
      web-endpoint: ${{ steps.get-endpoints.outputs.web-endpoint }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Build and Push Web Container Image
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      run: |
        # Get branch name for tagging
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        IMAGE_TAG=${BRANCH_NAME:-main}

        # Get ECR repository URI from CloudFormation outputs
        echo "Querying CloudFormation for ECR repository URI..."
        ECR_REPO=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`WebECRRepositoryUri`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

        # Debug: Show what we got from CloudFormation
        echo "CloudFormation query result: '$ECR_REPO'"

        # Fallback: construct ECR repo URI if CloudFormation query fails
        if [ -z "$ECR_REPO" ] || [ "$ECR_REPO" = "None" ] || [ "$ECR_REPO" = "null" ]; then
          echo "‚ùå CloudFormation ECR query failed or returned empty, using fallback URI"
          ECR_REPO="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/taskmanager-web"
          echo "üìù Constructed fallback ECR URI: $ECR_REPO"
        else
          echo "‚úÖ Successfully retrieved ECR URI from CloudFormation: $ECR_REPO"
        fi

        echo "üéØ Final ECR repository: $ECR_REPO"

        # Build container image from root context
        docker build -t taskmanager-web:$IMAGE_TAG -f src/TaskManager.Web/Dockerfile .

        # Login to ECR
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REPO

        # Tag and push image
        docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:$IMAGE_TAG
        docker push $ECR_REPO:$IMAGE_TAG

        # Also tag as latest for main branch
        if [ "$BRANCH_NAME" = "main" ]; then
          docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:latest
          docker push $ECR_REPO:latest
        fi

        echo "CONTAINER_IMAGE=$ECR_REPO:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Get branch name for stack naming
      run: |
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        STACK_NAME="taskmanager-${BRANCH_NAME}"
        echo "Branch: $BRANCH_NAME"
        echo "Stack name: $STACK_NAME"
        echo "STACK_NAME=$STACK_NAME" >> $GITHUB_ENV
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
        
    - name: Setup SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        use-installer: true
        
    - name: Cleanup failed branch stack (if exists)
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")
        
        if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
          echo "üóëÔ∏è Deleting failed branch stack: ${{ env.STACK_NAME }}"
          aws cloudformation delete-stack \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Failed branch stack cleaned up"
        fi
        
    - name: Download Lambda packages
      uses: actions/download-artifact@v4
      with:
        name: api-lambda-package
        path: ./artifacts/
        
        
    - name: Upload templates and packages to S3
      run: |
        # Get S3 bucket name from shared infrastructure stack
        BUCKET_NAME=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`TemplatesBucketName`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        # Debug: List downloaded artifacts
        echo "Downloaded artifacts:"
        ls -la ./artifacts/
        
        # Upload nested stack templates
        aws s3 cp src/TaskManager.Api/api-template.yaml s3://$BUCKET_NAME/api-template.yaml
        aws s3 cp src/TaskManager.Web/web-template.yaml s3://$BUCKET_NAME/web-template.yaml

        # Upload Lambda deployment packages
        aws s3 cp ./artifacts/api-lambda-deployment.zip s3://$BUCKET_NAME/api-lambda-deployment.zip
        
        # Verify uploads
        echo "S3 bucket contents:"
        aws s3 ls s3://$BUCKET_NAME/
        
        echo "TEMPLATE_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
        
    - name: Deploy Wrapper Template (Nested Stacks)
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: ${{ env.STACK_NAME }}
        template: wrapper-template.yaml
        parameter-overrides: |
          Environment=${{ env.BRANCH_NAME }},
          GoogleClientId=${{ secrets.GOOGLE_CLIENT_ID }},
          GoogleClientSecret=${{ secrets.GOOGLE_CLIENT_SECRET }},
          ApiCodeBucket=${{ env.TEMPLATE_BUCKET }},
          WebContainerImage=${{ env.CONTAINER_IMAGE }}
        capabilities: "CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 20
        
    - name: Setup branch database
      run: |
        echo "Setting up database for branch: ${{ env.BRANCH_NAME }}"

        # Get API endpoint from wrapper stack exports (most reliable method)
        # The wrapper stack exports the API endpoint with name: TaskManager-{Environment}-ApiEndpoint
        EXPORT_NAME="TaskManager-${{ env.BRANCH_NAME }}-ApiEndpoint"

        echo "Looking for CloudFormation export: $EXPORT_NAME"
        API_URL=$(aws cloudformation list-exports \
          --query "Exports[?Name=='$EXPORT_NAME'].Value" \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

        if [ -z "$API_URL" ] || [ "$API_URL" = "None" ]; then
          echo "‚ùå API endpoint export not found: $EXPORT_NAME"
          echo "This indicates the CloudFormation deployment failed or the export is not ready"
          exit 1
        fi

        echo "‚úÖ API endpoint from export: $API_URL"

        # Test API connectivity first
        echo "Testing API connectivity..."
        HEALTH_CHECK_CMD="curl -f -s --max-time 30 \"$API_URL/health\""
        echo "Executing: $HEALTH_CHECK_CMD"
        if ! eval "$HEALTH_CHECK_CMD" > /dev/null; then
          echo "‚ùå API health check failed"
          exit 1
        fi
        echo "‚úÖ API is healthy"

        # Setup database with proper error handling
        echo "Setting up database..."
        DB_SETUP_CMD="curl -s -w \"\nHTTP_STATUS:%{http_code}\" -X POST \"${API_URL}setup-database\" --max-time 60"
        echo "Executing: $DB_SETUP_CMD"
        DB_SETUP_RESPONSE=$(eval "$DB_SETUP_CMD")

        HTTP_STATUS=$(echo "$DB_SETUP_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
        RESPONSE_BODY=$(echo "$DB_SETUP_RESPONSE" | sed '/HTTP_STATUS:/d')

        echo "Database setup response: $RESPONSE_BODY"
        echo "HTTP Status: $HTTP_STATUS"

        if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ]; then
          echo "‚úÖ Database setup completed successfully"

          # Validate database setup by testing API connectivity
          echo "Validating database setup..."
          sleep 10  # Wait for database changes to propagate

          # Test health endpoint
          HEALTH_CHECK_CMD="curl -f -s --max-time 30 \"$API_URL/health\""
          echo "Executing: $HEALTH_CHECK_CMD"
          if eval "$HEALTH_CHECK_CMD" > /dev/null; then
            echo "‚úÖ API health check passed after database setup"
          else
            echo "‚ö†Ô∏è API health check failed, but database setup completed"
          fi

        else
          echo "‚ùå Database setup failed with HTTP status: $HTTP_STATUS"
          echo "Response: $RESPONSE_BODY"
          exit 1
        fi
        
    - name: Get deployment outputs
      id: get-endpoints
      run: |
        echo "Getting deployment outputs from CloudFormation exports..."

        # Get API endpoint from wrapper stack exports
        API_EXPORT_NAME="TaskManager-${{ env.BRANCH_NAME }}-ApiEndpoint"
        API_URL=$(aws cloudformation list-exports \
          --query "Exports[?Name=='$API_EXPORT_NAME'].Value" \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

        if [ -z "$API_URL" ] || [ "$API_URL" = "None" ]; then
          echo "‚ùå API endpoint export not found: $API_EXPORT_NAME"
          echo "Available exports:"
          aws cloudformation list-exports --region ${{ env.AWS_REGION }} 2>/dev/null || echo "No exports found"
          exit 1
        fi
        echo "‚úÖ API endpoint: $API_URL"

        # Get Web endpoint from wrapper stack exports
        WEB_EXPORT_NAME="TaskManager-${{ env.BRANCH_NAME }}-WebLoadBalancerDNS"
        WEB_URL=$(aws cloudformation list-exports \
          --query "Exports[?Name=='$WEB_EXPORT_NAME'].Value" \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

        if [ -z "$WEB_URL" ] || [ "$WEB_URL" = "None" ]; then
          echo "‚ö†Ô∏è Web endpoint export not found: $WEB_EXPORT_NAME"
          WEB_URL=""
        else
          echo "‚úÖ Web endpoint: $WEB_URL"
        fi

        BASTION_IP=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`BastionHostIP`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        TUNNEL_CMD=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`DatabaseTunnelCommand`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        # Extract API Gateway ID from URL
        API_GATEWAY_ID=$(echo $API_URL | sed 's|https://||' | sed 's|\.execute-api.*||')

        echo "üöÄ TaskManager (${{ env.BRANCH_NAME }}) deployed successfully!"
        echo "üìã API Stack: ${{ env.STACK_NAME }}-api ‚úÖ Endpoint: $API_URL"
        echo "üìã Web Stack: ${{ env.STACK_NAME }}-web ‚úÖ Load Balancer: $WEB_URL"
        echo "üñ•Ô∏è Bastion host IP: $BASTION_IP"
        echo "üíæ Database: taskmanager_${{ env.BRANCH_NAME }} ‚úÖ Setup verified"
        echo "üîó SSH Tunnel: $TUNNEL_CMD"

        # Set outputs for other jobs
        echo "api-endpoint=$API_URL" >> $GITHUB_OUTPUT
        echo "web-endpoint=$WEB_URL" >> $GITHUB_OUTPUT
        echo "api-gateway-id=$API_GATEWAY_ID" >> $GITHUB_OUTPUT
        
    - name: Send SMS Notification
      run: |
        # Get SNS topic ARN
        SNS_TOPIC=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`DeploymentNotificationTopicArn`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        # Send SMS notification
        aws sns publish \
          --topic-arn $SNS_TOPIC \
          --message "üöÄ TaskManager deployment complete!

        Branch: ${{ env.BRANCH_NAME }}
        API: $API_URL
        Web App: http://$WEB_URL
        Database: taskmanager_${{ env.BRANCH_NAME }} ‚úÖ Setup verified
        Bastion IP: $BASTION_IP

        Both API and Web are fully deployed and running!" \
          --subject "TaskManager Deployed - ${{ env.BRANCH_NAME }}" \
          --region ${{ env.AWS_REGION }}
        
        echo "üì± SMS notification sent to 703-474-0324"

  update-google-oauth:
    name: Generate Google OAuth Update Instructions
    runs-on: ubuntu-latest
    needs: deploy-application
    if: needs.deploy-application.result == 'success'

    steps:
    - name: Generate OAuth Update Instructions
      run: |
        # Get the API Gateway ID from the deployment outputs
        API_GATEWAY_ID="${{ needs.deploy-application.outputs.api-gateway-id }}"
        API_ENDPOINT="${{ needs.deploy-application.outputs.api-endpoint }}"
        WEB_ENDPOINT="${{ needs.deploy-application.outputs.web-endpoint }}"

        echo "üîß Google OAuth Configuration Update Required"
        echo "=============================================="
        echo ""
        echo "üìã Copy these values to update your Google OAuth configuration:"
        echo ""
        echo "üåê Google Cloud Console URL:"
        echo "   https://console.cloud.google.com/apis/credentials"
        echo ""
        echo "üìù OAuth Client ID:"
        echo "   ${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}"
        echo ""
        echo "üîó Authorized redirect URIs (add this):"
        echo "   https://${API_GATEWAY_ID}.execute-api.us-east-1.amazonaws.com/Prod/signin-google"
        echo ""
        echo "üåç Authorized JavaScript origins (add this):"
        echo "   https://${API_GATEWAY_ID}.execute-api.us-east-1.amazonaws.com"
        echo ""
        echo "üìã Steps:"
        echo "   1. Go to Google Cloud Console (link above)"
        echo "   2. Find and edit your OAuth 2.0 Client ID"
        echo "   3. Add the redirect URI listed above"
        echo "   4. Add the JavaScript origin listed above"
        echo "   5. Save changes"
        echo ""
        echo "‚úÖ After updating, Google OAuth login will work!"
        echo ""
        echo "üîç Current deployment URLs:"
        echo "   API: ${{ needs.deploy-application.outputs.api-endpoint }}"
        echo "   Web Application: http://${{ needs.deploy-application.outputs.web-endpoint }}"
        echo "   API Gateway ID: ${API_GATEWAY_ID}"
