# TaskManager CI/CD Pipeline - Shared Infrastructure + Branch Applications

name: TaskManager CI/CD

on:
  push:
  pull_request:

env:
  AWS_REGION: us-east-1

jobs:
  yaml-lint:
    name: YAML Lint
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Install yamllint
      run: pip install yamllint
      
    - name: Lint YAML files
      run: |
        echo "Linting all .yml and .yaml files in the repository (excluding .github/workflows/dotnet.yml)..."
        find . -name "*.yml" -o -name "*.yaml" | grep -v ".github/workflows/dotnet.yml" | while read file; do
          echo "Linting: $file"
          yamllint -c .yamllint.yml "$file"
        done
        
        # Check if any linting errors occurred
        if find . -name "*.yml" -o -name "*.yaml" | grep -v ".github/workflows/dotnet.yml" | xargs yamllint -c .yamllint.yml | grep -q "error"; then
          echo "‚ùå YAML linting failed!"
          exit 1
        else
          echo "‚úÖ All YAML files passed linting!"
        fi

  build:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
        
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
          
    - name: Restore dependencies
      run: dotnet restore
      
    - name: Build
      run: dotnet build --no-restore --configuration Release
      
    - name: Test
      run: dotnet test --no-build --verbosity normal --configuration Release
      
    - name: Publish API for Lambda
      run: dotnet publish src/TaskManager.Api/TaskManager.Api.csproj --configuration Release --output ./publish/api --runtime linux-x64 --self-contained false
      
    - name: Publish Web for Lambda
      run: dotnet publish src/TaskManager.Web/TaskManager.Web.csproj --configuration Release --output ./publish/web --runtime linux-x64 --self-contained false /p:GenerateRuntimeConfigurationFiles=true
      
    - name: Create API Lambda deployment package
      run: |
        cd ./publish/api
        zip -r ../../api-lambda-deployment.zip .
        
    - name: Create Web Lambda deployment package
      run: |
        cd ./publish/web
        zip -r ../../web-lambda-deployment.zip .
        
    - name: Upload API Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: api-lambda-package
        path: api-lambda-deployment.zip
        
    - name: Upload Web Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: web-lambda-package
        path: web-lambda-deployment.zip

  deploy-infrastructure:
    name: Deploy Shared Infrastructure
    runs-on: ubuntu-latest
    needs: build
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Deploy Shared Infrastructure
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-shared-infrastructure
        template: infrastructure/shared-infrastructure.yaml
        parameter-overrides: |
          DatabasePassword=${{ secrets.DATABASE_PASSWORD }}
        capabilities: "CAPABILITY_NAMED_IAM"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 15

  deploy-application:
    name: Deploy Branch Application
    runs-on: ubuntu-latest
    needs: [build, deploy-infrastructure, yaml-lint]
    outputs:
      api-endpoint: ${{ steps.get-endpoints.outputs.api-endpoint }}
      web-endpoint: ${{ steps.get-endpoints.outputs.web-endpoint }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Build and Push Web Container Image
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      run: |
        # Get branch name for tagging
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        IMAGE_TAG=${BRANCH_NAME:-main}

        # Get ECR repository URI from CloudFormation outputs
        ECR_REPO=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`WebECRRepositoryUri`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

        # Fallback: construct ECR repo URI if CloudFormation query fails
        if [ -z "$ECR_REPO" ] || [ "$ECR_REPO" = "None" ]; then
          echo "CloudFormation ECR query failed, using fallback URI"
          ECR_REPO="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/taskmanager-web"
        fi

        echo "Using ECR repository: $ECR_REPO"

        # Build container image from root context
        docker build -t taskmanager-web:$IMAGE_TAG -f src/TaskManager.Web/Dockerfile .

        # Login to ECR
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

        # Tag and push image
        docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:$IMAGE_TAG
        docker push $ECR_REPO:$IMAGE_TAG

        # Also tag as latest for main branch
        if [ "$BRANCH_NAME" = "main" ]; then
          docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:latest
          docker push $ECR_REPO:latest
        fi

        echo "CONTAINER_IMAGE=$ECR_REPO:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Get branch name for stack naming
      run: |
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        STACK_NAME="taskmanager-${BRANCH_NAME}"
        echo "Branch: $BRANCH_NAME"
        echo "Stack name: $STACK_NAME"
        echo "STACK_NAME=$STACK_NAME" >> $GITHUB_ENV
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
        
    - name: Setup SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        use-installer: true
        
    - name: Cleanup failed branch stack (if exists)
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")
        
        if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
          echo "üóëÔ∏è Deleting failed branch stack: ${{ env.STACK_NAME }}"
          aws cloudformation delete-stack \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Failed branch stack cleaned up"
        fi
        
    - name: Download Lambda packages
      uses: actions/download-artifact@v4
      with:
        name: api-lambda-package
        path: ./artifacts/
        
    - name: Download Web Lambda package
      uses: actions/download-artifact@v4
      with:
        name: web-lambda-package
        path: ./artifacts/
        
    - name: Upload templates and packages to S3
      run: |
        # Get S3 bucket name from shared infrastructure stack
        BUCKET_NAME=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`TemplatesBucketName`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        # Debug: List downloaded artifacts
        echo "Downloaded artifacts:"
        ls -la ./artifacts/
        
        # Upload nested stack templates
        aws s3 cp src/TaskManager.Api/api-template.yaml s3://$BUCKET_NAME/api-template.yaml
        aws s3 cp src/TaskManager.Web/web-template.yaml s3://$BUCKET_NAME/web-template.yaml
        
        # Upload Lambda deployment packages
        aws s3 cp ./artifacts/api-lambda-deployment.zip s3://$BUCKET_NAME/api-lambda-deployment.zip
        aws s3 cp ./artifacts/web-lambda-deployment.zip s3://$BUCKET_NAME/web-lambda-deployment.zip
        
        # Verify uploads
        echo "S3 bucket contents:"
        aws s3 ls s3://$BUCKET_NAME/
        
        echo "TEMPLATE_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
        
    - name: Deploy Wrapper Template (Nested Stacks)
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: ${{ env.STACK_NAME }}
        template: wrapper-template.yaml
        parameter-overrides: |
          Environment=${{ env.BRANCH_NAME }},
          GoogleClientId=${{ secrets.GOOGLE_CLIENT_ID }},
          GoogleClientSecret=${{ secrets.GOOGLE_CLIENT_SECRET }},
          ApiCodeBucket=${{ env.TEMPLATE_BUCKET }},
          WebContainerImage=${{ env.CONTAINER_IMAGE }}
        capabilities: "CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 20
        
    - name: Setup branch database
      run: |
        # Get API URL from parent stack outputs
        API_URL=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --query 'Stacks[0].Outputs[?OutputKey==`TaskManager-main-ApiEndpoint`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        echo "Setting up database for branch: ${{ env.BRANCH_NAME }}"
        echo "Using API URL: $API_URL"
        curl -X POST "${API_URL}setup-database" || echo "Database setup completed"
        
    - name: Get deployment outputs
      id: get-endpoints
      run: |
        # Get outputs from parent stack instead of nested stacks
        API_URL=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --query 'Stacks[0].Outputs[?OutputKey==`TaskManager-main-ApiEndpoint`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        WEB_URL=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --query 'Stacks[0].Outputs[?OutputKey==`TaskManager-main-WebEndpoint`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        BASTION_IP=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`BastionHostIP`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        TUNNEL_CMD=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`DatabaseTunnelCommand`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        # Extract API Gateway ID from URL
        API_GATEWAY_ID=$(echo $API_URL | sed 's|https://||' | sed 's|\.execute-api.*||')

        echo "üöÄ TaskManager (${{ env.BRANCH_NAME }}) deployed successfully!"
        echo "üìã API Stack: ${{ env.STACK_NAME }}-api"
        echo "üìã Web Stack: ${{ env.STACK_NAME }}-web"
        echo "üåê Web Application: $WEB_URL"
        echo "üîó API Endpoint: $API_URL"
        echo "üñ•Ô∏è Bastion host IP: $BASTION_IP"
        echo "üíæ Database: taskmanager_${{ env.BRANCH_NAME }}"
        echo "üîó SSH Tunnel: $TUNNEL_CMD"

        # Set outputs for other jobs
        echo "api-endpoint=$API_URL" >> $GITHUB_OUTPUT
        echo "web-endpoint=$WEB_URL" >> $GITHUB_OUTPUT
        echo "api-gateway-id=$API_GATEWAY_ID" >> $GITHUB_OUTPUT
        
    - name: Send SMS Notification
      run: |
        # Get SNS topic ARN
        SNS_TOPIC=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`DeploymentNotificationTopicArn`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        # Send SMS notification
        aws sns publish \
          --topic-arn $SNS_TOPIC \
          --message "üöÄ TaskManager deployment complete!

        Branch: ${{ env.BRANCH_NAME }}
        Web App: $WEB_URL
        API: $API_URL
        Database: taskmanager_${{ env.BRANCH_NAME }}
        Bastion IP: $BASTION_IP

        Ready for testing!" \
          --subject "TaskManager Deployed - ${{ env.BRANCH_NAME }}" \
          --region ${{ env.AWS_REGION }}
        
        echo "üì± SMS notification sent to 703-474-0324"

  update-google-oauth:
    name: Generate Google OAuth Update Instructions
    runs-on: ubuntu-latest
    needs: deploy-application
    if: needs.deploy-application.result == 'success'

    steps:
    - name: Generate OAuth Update Instructions
      run: |
        # Get the API Gateway ID from the deployment outputs
        API_GATEWAY_ID="${{ needs.deploy-application.outputs.api-gateway-id }}"
        API_ENDPOINT="${{ needs.deploy-application.outputs.api-endpoint }}"
        WEB_ENDPOINT="${{ needs.deploy-application.outputs.web-endpoint }}"

        echo "üîß Google OAuth Configuration Update Required"
        echo "=============================================="
        echo ""
        echo "üìã Copy these values to update your Google OAuth configuration:"
        echo ""
        echo "üåê Google Cloud Console URL:"
        echo "   https://console.cloud.google.com/apis/credentials"
        echo ""
        echo "üìù OAuth Client ID:"
        echo "   ${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}"
        echo ""
        echo "üîó Authorized redirect URIs (add this):"
        echo "   https://${API_GATEWAY_ID}.execute-api.us-east-1.amazonaws.com/Prod/signin-google"
        echo ""
        echo "üåç Authorized JavaScript origins (add this):"
        echo "   https://${API_GATEWAY_ID}.execute-api.us-east-1.amazonaws.com"
        echo ""
        echo "üìã Steps:"
        echo "   1. Go to Google Cloud Console (link above)"
        echo "   2. Find and edit your OAuth 2.0 Client ID"
        echo "   3. Add the redirect URI listed above"
        echo "   4. Add the JavaScript origin listed above"
        echo "   5. Save changes"
        echo ""
        echo "‚úÖ After updating, Google OAuth login will work!"
        echo ""
        echo "üîç Current deployment URLs:"
        echo "   Web App: ${{ needs.deploy-application.outputs.web-endpoint }}"
        echo "   API: ${{ needs.deploy-application.outputs.api-endpoint }}"
        echo "   API Gateway ID: ${API_GATEWAY_ID}"
