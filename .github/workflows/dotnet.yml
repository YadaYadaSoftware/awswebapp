# TaskManager CI/CD Pipeline - Shared Infrastructure + Branch Applications

name: TaskManager CI/CD

on:
  push:
  pull_request:

env:
  AWS_REGION: us-east-1

jobs:
  yaml-lint:
    name: YAML Lint
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Install yamllint
      run: pip install yamllint
      
    - name: Lint YAML files
      run: |
        echo "Linting all .yml and .yaml files in the repository (excluding .github/workflows/dotnet.yml)..."
        find . -name "*.yml" -o -name "*.yaml" | grep -v ".github/workflows/dotnet.yml" | while read file; do
          echo "Linting: $file"
          yamllint -c .yamllint.yml "$file"
        done
        
        # Check if any linting errors occurred
        if find . -name "*.yml" -o -name "*.yaml" | grep -v ".github/workflows/dotnet.yml" | xargs yamllint -c .yamllint.yml | grep -q "error"; then
          echo "‚ùå YAML linting failed!"
          exit 1
        else
          echo "‚úÖ All YAML files passed linting!"
        fi

  build:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x

    - name: Setup GitVersion
      uses: gittools/actions/gitversion/setup@v0
      with:
        versionSpec: '5.x'

    - name: Unshallow repository if needed
      run: |
        if [ "$(git rev-parse --is-shallow-repository)" = "true" ]; then
          echo "Repository is shallow, unshallowing..."
          git fetch --unshallow
        else
          echo "Repository is not shallow"
        fi

    - name: Determine Version
      id: gitversion
      uses: gittools/actions/gitversion/execute@v0
      with:
        useConfigFile: true

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore
      
    - name: Build
      run: |
        echo "Building with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet build --no-restore --configuration Release /p:Version=${{ steps.gitversion.outputs.semVer }} /p:AssemblyVersion=${{ steps.gitversion.outputs.assemblySemVer }} /p:FileVersion=${{ steps.gitversion.outputs.assemblySemVer }}
      
    - name: Test
      run: dotnet test --no-build --verbosity normal --configuration Release
      
    - name: Publish API for Lambda
      run: |
        echo "Publishing API with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet publish src/TaskManager.Api/TaskManager.Api.csproj --configuration Release --output ./publish/api --runtime linux-x64 --self-contained false /p:Version=${{ steps.gitversion.outputs.semVer }}

    - name: Publish Web for Container
      run: |
        echo "Publishing Web with version: ${{ steps.gitversion.outputs.semVer }}"
        dotnet publish src/TaskManager.Web/TaskManager.Web.csproj --configuration Release --output ./publish/web --runtime linux-x64 --self-contained false /p:Version=${{ steps.gitversion.outputs.semVer }}

    - name: Create API Lambda deployment package
      run: |
        cd ./publish/api
        zip -r ../../api-lambda-deployment.zip .

    - name: Upload API Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: api-lambda-package
        path: api-lambda-deployment.zip

    - name: Create PostgreSQL Lambda Layer
      run: |
        # Create layer directory structure
        mkdir -p python/lib/python3.9/site-packages

        # Install pg8000 (pure Python PostgreSQL driver)
        pip install pg8000 -t python/lib/python3.9/site-packages/

        # Create layer ZIP file
        zip -r postgres-layer.zip python/

        echo "PostgreSQL layer created successfully"

    - name: Upload PostgreSQL Layer
      uses: actions/upload-artifact@v4
      with:
        name: postgres-layer-package
        path: postgres-layer.zip

  deploy-infrastructure:
    name: Deploy Shared Infrastructure
    runs-on: ubuntu-latest
    needs: build
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Deploy Shared Infrastructure
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: taskmanager-shared-infrastructure
        template: infrastructure/shared-infrastructure.yaml
        parameter-overrides: |
          DatabasePassword=${{ secrets.DATABASE_PASSWORD }}
        capabilities: "CAPABILITY_NAMED_IAM"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 15

  deploy-application:
    name: Deploy Branch Application
    runs-on: ubuntu-latest
    needs: [build, deploy-infrastructure, yaml-lint]
    outputs:
      api-endpoint: ${{ steps.get-endpoints.outputs.api-endpoint }}
      web-endpoint: ${{ steps.get-endpoints.outputs.web-endpoint }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Build and Push Web Container Image
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      run: |
        # Get branch name for tagging
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        IMAGE_TAG=${BRANCH_NAME:-main}

        # Get ECR repository URI from CloudFormation outputs
        echo "Querying CloudFormation for ECR repository URI..."
        ECR_REPO=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`WebECRRepositoryUri`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

        # Debug: Show what we got from CloudFormation
        echo "CloudFormation query result: '$ECR_REPO'"

        # Fallback: construct ECR repo URI if CloudFormation query fails
        if [ -z "$ECR_REPO" ] || [ "$ECR_REPO" = "None" ] || [ "$ECR_REPO" = "null" ]; then
          echo "‚ùå CloudFormation ECR query failed or returned empty, using fallback URI"
          ECR_REPO="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/taskmanager-web"
          echo "üìù Constructed fallback ECR URI: $ECR_REPO"
        else
          echo "‚úÖ Successfully retrieved ECR URI from CloudFormation: $ECR_REPO"
        fi

        echo "üéØ Final ECR repository: $ECR_REPO"

        # Build container image from root context
        docker build -t taskmanager-web:$IMAGE_TAG -f src/TaskManager.Web/Dockerfile .

        # Login to ECR
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REPO

        # Tag and push image
        docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:$IMAGE_TAG
        docker push $ECR_REPO:$IMAGE_TAG

        # Also tag as latest for main branch
        if [ "$BRANCH_NAME" = "main" ]; then
          docker tag taskmanager-web:$IMAGE_TAG $ECR_REPO:latest
          docker push $ECR_REPO:latest
        fi

        echo "CONTAINER_IMAGE=$ECR_REPO:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Get branch name for stack naming
      run: |
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        STACK_NAME="taskmanager-${BRANCH_NAME}"
        echo "Branch: $BRANCH_NAME"
        echo "Stack name: $STACK_NAME"
        echo "STACK_NAME=$STACK_NAME" >> $GITHUB_ENV
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
        
    - name: Setup SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        use-installer: true
        
    - name: Cleanup failed branch stack (if exists)
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name ${{ env.STACK_NAME }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")
        
        if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
          echo "üóëÔ∏è Deleting failed branch stack: ${{ env.STACK_NAME }}"
          aws cloudformation delete-stack \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Failed branch stack cleaned up"
        fi
        
    - name: Download Lambda packages
      uses: actions/download-artifact@v4
      with:
        name: api-lambda-package
        path: ./artifacts/

    - name: Download PostgreSQL Layer
      uses: actions/download-artifact@v4
      with:
        name: postgres-layer-package
        path: ./artifacts/


    - name: Upload templates and packages to S3
      run: |
        # Get S3 bucket name from shared infrastructure stack
        BUCKET_NAME=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`TemplatesBucketName`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        # Debug: List downloaded artifacts
        echo "Downloaded artifacts:"
        ls -la ./artifacts/
        
        # Upload nested stack templates
        aws s3 cp src/TaskManager.Api/api-template.yaml s3://$BUCKET_NAME/api-template.yaml
        aws s3 cp src/TaskManager.Web/web-template.yaml s3://$BUCKET_NAME/web-template.yaml

        # Upload Lambda deployment packages
        aws s3 cp ./artifacts/api-lambda-deployment.zip s3://$BUCKET_NAME/api-lambda-deployment.zip

        # Upload PostgreSQL layer
        aws s3 cp ./artifacts/postgres-layer.zip s3://$BUCKET_NAME/postgres-layer.zip
        
        # Verify uploads
        echo "S3 bucket contents:"
        aws s3 ls s3://$BUCKET_NAME/
        
        echo "TEMPLATE_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
        
    - name: Deploy Wrapper Template (Nested Stacks)
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: ${{ env.STACK_NAME }}
        template: wrapper-template.yaml
        parameter-overrides: |
          Environment=${{ env.BRANCH_NAME }},
          GoogleClientId=${{ secrets.GOOGLE_CLIENT_ID }},
          GoogleClientSecret=${{ secrets.GOOGLE_CLIENT_SECRET }},
          ApiCodeBucket=${{ env.TEMPLATE_BUCKET }},
          WebContainerImage=${{ env.CONTAINER_IMAGE }},
          DomainName=appcloud.systems,
          HostedZoneId=Z06422172SASV44F5Y8VA
        capabilities: "CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND"
        no-fail-on-empty-changeset: "1"
      timeout-minutes: 20
        
    - name: Setup branch database
      run: |
        echo "Setting up database for branch: ${{ env.BRANCH_NAME }}"

        # Get API endpoint from wrapper stack exports (most reliable method)
        # The wrapper stack exports the API endpoint with name: TaskManager-{Environment}-ApiEndpoint
        EXPORT_NAME="TaskManager-${{ env.BRANCH_NAME }}-ApiEndpoint"

        echo "Looking for CloudFormation export: $EXPORT_NAME"
        API_URL=$(aws cloudformation list-exports \
          --query "Exports[?Name=='$EXPORT_NAME'].Value" \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

        if [ -z "$API_URL" ] || [ "$API_URL" = "None" ]; then
          echo "‚ùå API endpoint export not found: $EXPORT_NAME"
          echo "This indicates the CloudFormation deployment failed or the export is not ready"
          exit 1
        fi

        echo "‚úÖ API endpoint from export: $API_URL"

        # Test API connectivity first
        echo "Testing API connectivity..."
        HEALTH_CHECK_CMD="curl -f -s --max-time 30 \"$API_URL/health\""
        echo "Executing: $HEALTH_CHECK_CMD"
        if ! eval "$HEALTH_CHECK_CMD" > /dev/null; then
          echo "‚ùå API health check failed"
          exit 1
        fi
        echo "‚úÖ API is healthy"

        # Setup database with token authentication
        echo "Setting up database..."
        DB_SETUP_CMD="curl -s -w \"\nHTTP_STATUS:%{http_code}\" -X POST \"${API_URL}setup-database\" -H \"Authorization: taskmanager-setup-secure-token-2024\" --max-time 60"
        echo "Executing: $DB_SETUP_CMD"
        DB_SETUP_RESPONSE=$(eval "$DB_SETUP_CMD")

        HTTP_STATUS=$(echo "$DB_SETUP_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
        RESPONSE_BODY=$(echo "$DB_SETUP_RESPONSE" | sed '/HTTP_STATUS:/d')

        echo "Database setup response: $RESPONSE_BODY"
        echo "HTTP Status: $HTTP_STATUS"

        if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ]; then
          echo "‚úÖ Database setup completed successfully"
        else
          echo "‚ùå Database setup failed with HTTP status: $HTTP_STATUS"
          exit 1
        fi

        HTTP_STATUS=$(echo "$DB_SETUP_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
        RESPONSE_BODY=$(echo "$DB_SETUP_RESPONSE" | sed '/HTTP_STATUS:/d')

        echo "Database setup response: $RESPONSE_BODY"
        echo "HTTP Status: $HTTP_STATUS"

        if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ]; then
          echo "‚úÖ Database setup completed successfully"

          # Validate database setup by testing API connectivity
          echo "Validating database setup..."
          sleep 10  # Wait for database changes to propagate

          # Test health endpoint
          HEALTH_CHECK_CMD="curl -f -s --max-time 30 \"$API_URL/health\""
          echo "Executing: $HEALTH_CHECK_CMD"
          if eval "$HEALTH_CHECK_CMD" > /dev/null; then
            echo "‚úÖ API health check passed after database setup"
          else
            echo "‚ö†Ô∏è API health check failed, but database setup completed"
          fi

        else
          echo "‚ùå Database setup failed with HTTP status: $HTTP_STATUS"
          echo "Response: $RESPONSE_BODY"
          exit 1
        fi
        
    - name: Get deployment outputs
      id: get-endpoints
      run: |
        echo "Getting deployment outputs from CloudFormation exports..."

        # Get API endpoint from wrapper stack exports
        API_EXPORT_NAME="TaskManager-${{ env.BRANCH_NAME }}-ApiEndpoint"
        API_URL=$(aws cloudformation list-exports \
          --query "Exports[?Name=='$API_EXPORT_NAME'].Value" \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

        if [ -z "$API_URL" ] || [ "$API_URL" = "None" ]; then
          echo "‚ùå API endpoint export not found: $API_EXPORT_NAME"
          echo "Available exports:"
          aws cloudformation list-exports --region ${{ env.AWS_REGION }} 2>/dev/null || echo "No exports found"
          exit 1
        fi
        echo "‚úÖ API endpoint: $API_URL"

        # Get Web endpoint from wrapper stack exports
        WEB_EXPORT_NAME="TaskManager-${{ env.BRANCH_NAME }}-WebLoadBalancerDNS"
        WEB_URL=$(aws cloudformation list-exports \
          --query "Exports[?Name=='$WEB_EXPORT_NAME'].Value" \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")

        if [ -z "$WEB_URL" ] || [ "$WEB_URL" = "None" ]; then
          echo "‚ö†Ô∏è Web endpoint export not found: $WEB_EXPORT_NAME"
          WEB_URL=""
        else
          echo "‚úÖ Web endpoint: $WEB_URL"
        fi

        BASTION_IP=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`BastionHostIP`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        TUNNEL_CMD=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`DatabaseTunnelCommand`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        # Extract API Gateway ID from URL
        API_GATEWAY_ID=$(echo $API_URL | sed 's|https://||' | sed 's|\.execute-api.*||')

        echo "üöÄ TaskManager (${{ env.BRANCH_NAME }}) deployed successfully!"
        echo "üìã API Stack: ${{ env.STACK_NAME }}-api ‚úÖ Endpoint: $API_URL"
        echo "üìã Web Stack: ${{ env.STACK_NAME }}-web ‚úÖ Load Balancer: $WEB_URL"
        echo "üñ•Ô∏è Bastion host IP: $BASTION_IP"
        echo "üíæ Database: taskmanager_${{ env.BRANCH_NAME }} ‚úÖ Setup verified"
        echo "üîó SSH Tunnel: $TUNNEL_CMD"

        # Set outputs for other jobs
        echo "api-endpoint=$API_URL" >> $GITHUB_OUTPUT
        echo "web-endpoint=$WEB_URL" >> $GITHUB_OUTPUT
        echo "api-gateway-id=$API_GATEWAY_ID" >> $GITHUB_OUTPUT
        
    - name: Send SMS Notification
      run: |
        # Get SNS topic ARN
        SNS_TOPIC=$(aws cloudformation describe-stacks \
          --stack-name taskmanager-shared-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`DeploymentNotificationTopicArn`].OutputValue' \
          --output text \
          --region ${{ env.AWS_REGION }})

        # Send SMS notification
        aws sns publish \
          --topic-arn $SNS_TOPIC \
          --message "üöÄ TaskManager deployment complete!

        Branch: ${{ env.BRANCH_NAME }}
        API: $API_URL
        Web App: https://$BRANCH_NAME.appcloud.systems
        Database: taskmanager_${{ env.BRANCH_NAME }} ‚úÖ Setup verified
        Bastion IP: $BASTION_IP

        Both API and Web are fully deployed and running!" \
          --subject "TaskManager Deployed - ${{ env.BRANCH_NAME }}" \
          --region ${{ env.AWS_REGION }}
        
        echo "üì± SMS notification sent to 703-474-0324"

  update-google-oauth:
    name: Generate Google OAuth Update Instructions
    runs-on: ubuntu-latest
    needs: deploy-application
    if: needs.deploy-application.result == 'success'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Update Google OAuth Configuration
      run: |
        chmod +x update-google-oauth.sh
        ./update-google-oauth.sh "${{ needs.deploy-application.outputs.api-endpoint }}" "${{ needs.deploy-application.outputs.web-endpoint }}"
