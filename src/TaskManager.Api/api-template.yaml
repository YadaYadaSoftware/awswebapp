AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'TaskManager API - Lambda Function with Branch-Specific Database'

Parameters:
  Environment:
    Type: String
    Default: main
    Description: 'Environment name (typically branch name)'
    
  GoogleClientId:
    Type: String
    NoEcho: true
    Description: 'Google OAuth Client ID'
    
  GoogleClientSecret:
    Type: String
    NoEcho: true
    Description: 'Google OAuth Client Secret'
    
  ApiCodeBucket:
    Type: String
    Description: 'S3 bucket name for API Lambda deployment package'
    
  ApiCodeKey:
    Type: String
    Description: 'S3 key for API Lambda deployment package'
    Default: 'api-lambda-deployment.zip'

Globals:
  Function:
    Runtime: dotnet8
    Timeout: 60
    MemorySize: 512
    Environment:
      Variables:
        ASPNETCORE_ENVIRONMENT: !Ref Environment

Resources:
  # CloudWatch Log Group for Database Setup
  DatabaseSetupLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/TaskManager-DbSetup-${Environment}'
      RetentionInDays: 7

  # CloudWatch Log Group for API
  ApiLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/TaskManagerApi-${Environment}'
      RetentionInDays: 7

  # Lambda Layer for PostgreSQL dependencies
  PostgresLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub 'taskmanager-postgres-layer-${Environment}'
      Description: 'PostgreSQL dependencies for Lambda'
      Content:
        S3Bucket: !Ref ApiCodeBucket
        S3Key: 'postgres-layer.zip'
      CompatibleRuntimes:
        - python3.9

  # Branch-specific database creation Lambda
  DatabaseSetupFunction:
    Type: AWS::Serverless::Function
    DependsOn:
      - DatabaseSetupLogGroup
      - PostgresLayer
    Properties:
      FunctionName: !Sub 'TaskManager-DbSetup-${Environment}'
      Timeout: 120
      Layers:
        - !Ref PostgresLayer
      InlineCode: |
        import json
        import boto3
        import os
        import logging
        import pg8000

        logger = logging.getLogger()
        logger.setLevel(logging.INFO)

        def lambda_handler(event, context):
            try:
                # Simple token-based authentication for CI/CD access
                auth_token = event.get('headers', {}).get('Authorization') or \
                            event.get('queryStringParameters', {}).get('token', '')
                expected_token = os.environ.get('SETUP_AUTH_TOKEN', 'taskmanager-setup-token')

                if auth_token != expected_token:
                    logger.warning("Unauthorized access attempt to setup-database endpoint")
                    return {
                        'statusCode': 401,
                        'body': json.dumps({'error': 'Unauthorized'})
                    }

                # Validate required environment variables
                required_vars = ['BRANCH_NAME', 'DB_HOST', 'DB_USER', 'DB_PASSWORD']
                missing_vars = [var for var in required_vars \
                               if var not in os.environ or not os.environ[var]]

                if missing_vars:
                    error_msg = f"Missing required environment variables: {', '.join(missing_vars)}"
                    logger.error(error_msg)
                    return {
                        'statusCode': 500,
                        'body': json.dumps({'error': error_msg})
                    }

                # Create branch-specific database name
                branch_name = os.environ['BRANCH_NAME']
                db_name = f"taskmanager_{branch_name}"

                # Validate database name (basic validation)
                if not all(c.isalnum() or c in '_-' for c in db_name):
                    error_msg = f"Invalid database name: {db_name}"
                    logger.error(error_msg)
                    return {
                        'statusCode': 400,
                        'body': json.dumps({'error': error_msg})
                    }

                logger.info(f"Attempting to setup database: {db_name}")

                # Connect to PostgreSQL using pg8000
                try:
                    conn = pg8000.connect(
                        host=os.environ['DB_HOST'],
                        user=os.environ['DB_USER'],
                        password=os.environ['DB_PASSWORD'],
                        database='postgres'
                    )
                    logger.info("Successfully connected to PostgreSQL")

                    cursor = conn.cursor()

                    # Check if database exists (using parameterized query)
                    cursor.execute("SELECT 1 FROM pg_database WHERE datname = %s", [db_name])
                    exists = cursor.fetchone()

                    if not exists:
                        # Create database with proper quoting - use string formatting for database name
                        cursor.execute('CREATE DATABASE "%s"' % db_name)
                        logger.info(f"Created database: {db_name}")
                        message = f"Database {db_name} created successfully"
                    else:
                        logger.info(f"Database already exists: {db_name}")
                        message = f"Database {db_name} already exists"

                    cursor.close()
                    conn.close()

                    return {
                        'statusCode': 200,
                        'body': json.dumps({'message': message, 'database': db_name})
                    }

                except Exception as e:
                    error_msg = f"Database operation failed: {str(e)}"
                    logger.error(error_msg)
                    return {
                        'statusCode': 500,
                        'body': json.dumps({'error': error_msg})
                    }

            except Exception as e:
                error_msg = f"Unexpected error: {str(e)}"
                logger.error(error_msg)
                return {
                    'statusCode': 500,
                    'body': json.dumps({'error': error_msg})
                }
      Handler: index.lambda_handler
      Runtime: python3.9
      Role: 
        Fn::ImportValue: 'TaskManager-SharedLambdaRole'
      Environment:
        Variables:
          BRANCH_NAME: !Ref Environment
          DB_HOST:
            Fn::ImportValue: 'TaskManager-DatabaseEndpoint'
          DB_USER: taskmanager_admin
          DB_PASSWORD: !Sub '{{resolve:secretsmanager:taskmanager/database/shared:SecretString:password}}'
          SETUP_AUTH_TOKEN: 'taskmanager-setup-secure-token-2024'
      VpcConfig:
        SecurityGroupIds:
          - Fn::ImportValue: 'TaskManager-LambdaSecurityGroup'
        SubnetIds:
          - Fn::ImportValue: 'TaskManager-PrivateSubnet1'
          - Fn::ImportValue: 'TaskManager-PrivateSubnet2'
      Events:
        CreateDatabase:
          Type: Api
          Properties:
            Path: /setup-database
            Method: POST

  # TaskManager API Function
  TaskManagerApiFunction:
    Type: AWS::Serverless::Function
    DependsOn:
      - DatabaseSetupFunction
      - ApiLambdaLogGroup
    Properties:
      FunctionName: !Sub 'TaskManagerApi-${Environment}'
      CodeUri:
        Bucket: !Ref ApiCodeBucket
        Key: !Ref ApiCodeKey
      Handler: >-
        TaskManager.Api::TaskManager.Api.LambdaEntryPoint::FunctionHandlerAsync
      Runtime: dotnet8
      PackageType: Zip
      Role: 
        Fn::ImportValue: 'TaskManager-SharedLambdaRole'
      Environment:
        Variables:
          ASPNETCORE_ENVIRONMENT: !Ref Environment
          ConnectionStrings__DefaultConnection: !Sub
            - 'Host=${DatabaseEndpoint};Database=taskmanager_${DatabaseName};Username=taskmanager_admin;Password=${DatabasePassword}'
            - DatabaseEndpoint:
                Fn::ImportValue: 'TaskManager-DatabaseEndpoint'
              DatabaseName: !Sub '${Environment}'
              DatabasePassword: !Sub '{{resolve:secretsmanager:taskmanager/database/shared:SecretString:password}}'
          Authentication__Google__ClientId: !Ref GoogleClientId
          Authentication__Google__ClientSecret: !Ref GoogleClientSecret
      VpcConfig:
        SecurityGroupIds:
          - Fn::ImportValue: 'TaskManager-LambdaSecurityGroup'
        SubnetIds:
          - Fn::ImportValue: 'TaskManager-PrivateSubnet1'
          - Fn::ImportValue: 'TaskManager-PrivateSubnet2'
      Events:
        # Health check endpoint for deployment verification
        HealthCheck:
          Type: Api
          Properties:
            Path: /health
            Method: GET
        # Main API routes for application functionality
        ApiGatewayProxy:
          Type: Api
          Properties:
            Path: /api/{proxy+}
            Method: ANY
      Tags:
        Environment: !Ref Environment

  # CloudWatch Alarms for API
  LambdaErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub 'TaskManager-API-Errors-${Environment}'
      AlarmDescription: 'API Lambda function error rate alarm'
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref TaskManagerApiFunction

Outputs:
  ApiEndpoint:
    Description: 'API Gateway endpoint URL'
    Value: !Sub
      - 'https://${ApiId}.execute-api.${Region}.amazonaws.com/Prod/'
      - ApiId: !Ref ServerlessRestApi
        Region: !Ref AWS::Region

  ApiLambdaFunctionName:
    Description: 'API Lambda function name'
    Value: !Ref TaskManagerApiFunction

  DatabaseName:
    Description: 'Branch-specific database name'
    Value: !Sub 'taskmanager_${Environment}'

  BranchEnvironment:
    Description: 'Branch environment name'
    Value: !Ref Environment